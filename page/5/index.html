<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="study for goal">
<meta property="og:type" content="website">
<meta property="og:title" content="Meteor">
<meta property="og:url" content="/page/5/index.html">
<meta property="og:site_name" content="Meteor">
<meta property="og:description" content="study for goal">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Meteor">
<meta name="twitter:description" content="study for goal">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Meteor </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Meteor</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/(6.1).多线程-源码分析/" itemprop="url">
                  多线程源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T10:52:03+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AQS-AbstactQueuedSynchronizer-队列同步器"><a href="#AQS-AbstactQueuedSynchronizer-队列同步器" class="headerlink" title="AQS(AbstactQueuedSynchronizer)队列同步器"></a>AQS(AbstactQueuedSynchronizer)队列同步器</h2><h3 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h3><p>JDK1.7的java.util.concurrent.lock:</p>
<pre><code>AbstractQueuedSynchronizer (java.util.concurrent.locks)
    Sync in BaseFuture (org.elasticsearch.common.util.concurrent)
    Sync in CountDownLatch (java.util.concurrent)
    Sync in ReentrantLock (java.util.concurrent.locks)
    Sync in ReentrantReadWriteLock (java.util.concurrent.locks)
    Sync in Semaphore (java.util.concurrent)
    Worker in ThreadPoolExecutor (java.util.concurrent)
</code></pre><p>凡是继承AQS的类，都是线程安全的。</p>
<p>每个继承AQS的类内部都包含一个如下的内部类定义：</p>
<pre><code>//定义一个内部类
abstract static class Sync extends AbstractQueuedSynchronizer{
    /** 重构 **/
}
//维护一个Sync 的对象，用于线程同步安全
private final Sync sync;
</code></pre><h3 id="AQS的结构"><a href="#AQS的结构" class="headerlink" title="AQS的结构"></a>AQS的结构</h3><ul>
<li><p>2个重要内部类：ConditionObject和Node</p>
</li>
<li><p>3个重要属性:</p>
<pre><code>private transient volatile Node head;
private transient volatile Node tail;
private volatile int state;
</code></pre></li>
</ul>
<p>~~ java</p>
<pre><code>/**
 * Head of the wait queue, lazily initialized.  Except for
 * initialization, it is modified only via method setHead.  Note:
 * If head exists, its waitStatus is guaranteed not to be
 * CANCELLED.
 */
private transient volatile Node head;

/**
 * Tail of the wait queue, lazily initialized.  Modified only via
 * method enq to add new wait node.
 */
private transient volatile Node tail;

/**
 * The synchronization state.
 */
private volatile int state;    
</code></pre><p>注释其实已经告诉我们了，Node类型的head和tail是一个FIFO的wait queue；一个int类型的状态位state。到这里也能猜到AQS对外呈现（或者说声明）的主要行为就是由<strong>一个状态位</strong>和<strong>一个有序队列</strong>来配合完成.</p>
<p>~~ java</p>
<pre><code>//获取排它锁 X锁
 public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;&amp;
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}

//释放排它锁
public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}

//获取共享锁 S锁
public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
}

//释放共享锁 S锁
public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
</code></pre><p>AQS主要的工作思路正是如此：在获取锁时候，先判断当前状态是否允许获取锁，若是可以则获取锁，否则获取不成功。获取不成功则会阻塞，进入阻塞队列。而释放锁时，一般会修改状态位，唤醒队列中的阻塞线程。 跟踪这几个try字体的方法定义，发现一个惊人的巧合，这几个方法在AQS中居然都是一样的定义：</p>
<pre><code>protected boolean tr***(int arg) {
     throw new UnsupportedOperationException();
 }
</code></pre><p>即都是父类中只有定义，在子类中实现。</p>
<h3 id="AQS的重要方法"><a href="#AQS的重要方法" class="headerlink" title="AQS的重要方法"></a>AQS的重要方法</h3><p>简单看下下面几个方法的源码发现定义中都涉及到了getState(), setState(int) compareAndSetState(int, int)，即对状态位state的维护。</p>
<pre><code>tryAcquire(int)
tryRelease(int)
tryAcquireShared(int)
tryReleaseShared(int)
</code></pre><p>下图表示compareAndSetState(int, int)的调用，可以看的更清楚看到，说明几个同步工具类内定义的Sync类，即自定义子类中其实都涉及到对state的操作。</p>
<h3 id="常用同步工具类-AQS在子类中的使用"><a href="#常用同步工具类-AQS在子类中的使用" class="headerlink" title="常用同步工具类-AQS在子类中的使用"></a>常用同步工具类-AQS在子类中的使用</h3><p>对每个考察会从如下几个方面来进行:</p>
<ul>
<li>工具类的主要作用</li>
<li>主要获取锁方法（其他的类似方法如对应的可以更好的处理中断和超时或者异步等特性）</li>
<li>主要释放锁方法（其他的类似方法如对应的可以更好的处理中断和超时或者异步等特性）</li>
<li>工具类的构造方法（构造方法能告诉我们一个类最在意，最根本的属性）</li>
<li>Sync构造方法</li>
<li>Sync接口方法</li>
<li>Sync对AQS方法的override</li>
<li>state的作用</li>
<li>state维护重要逻辑</li>
</ul>
<h4 id="semaphore信号量"><a href="#semaphore信号量" class="headerlink" title="semaphore信号量"></a>semaphore信号量</h4><p><em>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire blocks if necessary until a permit is available, and then takes it. Each release adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.</em></p>
<p>信号量Semaphore的主要作用是来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。 Semaphore只是计数，不包括许可对象，并且Semaphore也不会把许可与线程对象关联起来，因此一个线程中获得的许可可以在另外一个线程中释放。<br>Semphore对外的两个方法是 acquire()和release()方法。</p>
<ul>
<li>acquire()：在许可可用前会阻塞每一个 acquire()，然后再获取该许可。</li>
<li>release():每调用 release() 添加一个许可，释放一个正在阻塞的获取者。</li>
</ul>
<p>达到这样的操作是通过同步器Sync来操作，可以是FairSync，也可以是NonfairSync。 从Sync的构造方法中，就可以看出Semphore中所谓的permit其实就是AQS中的state。</p>
<pre><code>public Semaphore(int permits, boolean fair) {
    sync = (fair)? new FairSync(permits) : new NonfairSync(permits);
}
Sync(int permits) {
    setState(permits);
}
</code></pre><p>在Semaphore中使用AQS的子类Sync，初始化state表示许可数，在每一次请求acquire()一个许可都会导致计数器减少1，同样每次释放一个许可release()都会导致计数器增加1。一旦达到了0，新的许可请求线程将被挂起。</p>
<h4 id="countdownlatch闭锁"><a href="#countdownlatch闭锁" class="headerlink" title="countdownlatch闭锁"></a>countdownlatch闭锁</h4><p><em>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes. A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown method, after which all waiting threads are released and any subsequent invocations of await return immediately.</em></p>
<p>就像名字Latch所表达的一样，把一组线程全部关在外面，在某个状态时候放开。即一种同步机制来保证一个或多个线程等待其他线程完成。初始化了一个count计数，当count未递减到0时候，每次调用await方法都会阻塞。每次调用countDown来是的的count递减。 </p>
<ul>
<li>构造方法</li>
</ul>
<p>~~ java</p>
<pre><code>public CountDownLatch(int count) {
    if (count &lt; 0) throw new IllegalArgumentException(&quot;count &lt; 0&quot;);
    this.sync = new Sync(count);
}
</code></pre><ul>
<li>重要方法 await和countDown</li>
</ul>
<p>定义await方法的作用是在计数器不为0时候阻塞调用线程，为0时候立即返回；countDown方法的作用是计数递减。</p>
<pre><code> public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}
 public void countDown() {
    sync.releaseShared(1);
}
</code></pre><h4 id="ReenTrantlock-可重入锁"><a href="#ReenTrantlock-可重入锁" class="headerlink" title="ReenTrantlock-可重入锁"></a>ReenTrantlock-可重入锁</h4><p> <em>A reentrant mutual exclusion Lock with the same basic behavior and semantics as the implicit monitor lock accessed using synchronized methods and statements, but with extended capabilities. A ReentrantLock is owned by the thread last successfully locking, but not yet unlocking it. A thread invoking lock will return, successfully acquiring the lock, when the lock is not owned by another thread. The method will return immediately if the current thread already owns the lock. This can be checked using methods isHeldByCurrentThread, and getHoldCount.</em></p>
<p>默认构造方法：(非公平锁实现)<br>    public ReentrantLock() {<br>        sync = new NonfairSync();<br>    }</p>
<p>基于AQS实现内部类Sync，有两种锁实现：</p>
<pre><code>AbstractQueuedSynchronizer (java.util.concurrent.locks)
    Sync in ReentrantLock (java.util.concurrent.locks)
        FairSync in ReentrantLock (java.util.concurrent.locks)
        NonfairSync in ReentrantLock (java.util.concurrent.locks)
</code></pre><ul>
<li><p>FairSync公平锁：总是调用acquire方法来和其他线程一样公平的尝试获取锁</p>
</li>
<li><p>NonfairSync非公平锁：只要当前没有线程持有锁，就将锁给当前线程，比如像使用tryLock</p>
</li>
</ul>
<p>~~ java</p>
<pre><code>/**NoFairSync**/
 final void lock() {
    if (compareAndSetState(0, 1))
        //对于非公平锁只要当前没有线程持有锁，就将锁给当前线程
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
}
/**FairSync**/
  final void lock() {
    acquire(1);
}
</code></pre><p> 对于非公平锁，通过state是否为0判断，当前是否有线程持有锁，如果没有则把锁分配给当前线程；否则如果state不为0，说明当前有线程持有锁，则判断持有锁的线程是否就是当前线程，如果是增加state计数，表示持有锁的线程的重入次数增加。当然增加重入数也会检查是否超过最大值。</p>
<p><strong>比较公平锁机制和非公平锁机制的差别仅仅在于如果当前没有线程持有锁，是优先把锁分配给当前线程，还是优先分配给等待队列中队首的线程。</strong></p>
<h4 id="FutureTask-异步"><a href="#FutureTask-异步" class="headerlink" title="FutureTask-异步"></a>FutureTask-异步</h4><p><em>A cancellable asynchronous computation. This class provides a base implementation of Future, with methods to start and cancel a computation, query to see if the computation is complete, and retrieve the result of the computation. The result can only be retrieved when the computation has completed; the get method will block if the computation has not yet completed. Once the computation has completed, the computation cannot be restarted or cancelled.</em></p>
<blockquote>
<p>类图：</p>
</blockquote>
<pre><code>FutureTask (java.util.concurrent)
    RunnableFuture (java.util.concurrent)
        Future (java.util.concurrent)
        Runnable (java.lang)
</code></pre><blockquote>
<p>构造方法：</p>
</blockquote>
<pre><code>public FutureTask(Runnable runnable, V result) {
    this.callable = Executors.callable(runnable, result);
    this.state = NEW;       // ensure visibility of callable
}

public FutureTask(Callable&lt;T&gt; callable) {
    if (callable == null)
        throw new NullPointerException();
    sync = new Sync(callable);
}
</code></pre><p>FutureTask实现了RunnableFuture接口，也即实现了Runnable和Future接口。作业线程执行的内容是FutureTask的的run方法内定义的任务内容。如线程池 ThreadPoolExecutor.Worker.runTask(Runnable task)方法可以看到在线程池的Worker线程中调用到执行任务的run方法。这里使用Sync的作用，就是在任务执行线程和提交任务（同时也是获取任务执行结果）的线程之间维持一个锁的关系，保证只有执行结束后才能获取到结果。</p>
<blockquote>
<p>通过future获取随机数的例子：</p>
</blockquote>
<pre><code>//callable
Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() {

    @Override
    public Integer call() throws Exception {
        //取1-100之间随机数
        return new Random().nextInt(100);
    }
};

FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callable);
new Thread(futureTask).start(); //可用线程启动 或用线程池启动

try {
    TimeUnit.SECONDS.sleep(5);

    Integer getNum = futureTask.get();
    System.out.println(&quot;getNum:&quot;+getNum);

} catch (InterruptedException e) {
    e.printStackTrace();
} catch (ExecutionException e) {
    e.printStackTrace();
}
</code></pre><p>总结：在FutureTask实现了异步的执行和提交，作为可以被Executor提交的对象。通过Sync来维护任务的执行状态，从而保证只有工作线程任务执行完后，其他线程才能获取到执行结果。AQS的子类Sync在这里主要是借用state状态位来存储执行状态，来完成对对各种状态以及加锁、阻塞的实现。</p>
<h2 id="CAS并发原子类"><a href="#CAS并发原子类" class="headerlink" title="CAS并发原子类"></a>CAS并发原子类</h2><p>CAS（Compare and swap）比较和替换是设计并发算法时用到的一种技术。简单来说，比较和替换是使用一个期望值和一个变量的当前值进行比较，如果当前变量的值与我们期望的值相等，就使用一个新值替换当前变量的值。这听起来可能有一点复杂但是实际上你理解之后发现很简单，接下来，让我们跟深入的了解一下这项技术。</p>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><ul>
<li><p>悲观锁：会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。 </p>
<p>  synchronized</p>
</li>
<li><p>乐观锁：每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p>
<p>  cas原子类</p>
</li>
</ul>
<h3 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h3><p>在程序和算法中一个经常出现的模式就是“check and act”模式。先检查后操作模式发生在代码中首先检查一个变量的值，然后再基于这个值做一些操作。使用cas原子类  目的 减少锁的使用，提高多线程并发执行，减少因为锁竞争 降低开销。</p>
<p>下面是一个使用AtomicBoolean类实现lock()方法的例子：</p>
<pre><code>public static class MyLock {
    private AtomicBoolean locked = new AtomicBoolean(false);

    public boolean lock() {
        return locked.compareAndSet(false, true);
    }
}
</code></pre><p>locked变量不再是boolean类型而是AtomicBoolean。这个类中有一个compareAndSet()方法，它使用一个期望值和AtomicBoolean实例的值比较，和两者相等，则使用一个新值替换原来的值。在这个例子中，它比较locked的值和false，如果locked的值为false，则把修改为true。<br>如果值被替换了，compareAndSet()返回true，否则，返回false。</p>
<p>参考：<a href="http://ifeve.com/compare-and-swap/" target="_blank" rel="external">http://ifeve.com/compare-and-swap/</a></p>
<h2 id="常用阻塞队列"><a href="#常用阻塞队列" class="headerlink" title="常用阻塞队列"></a>常用阻塞队列</h2><h3 id="阻塞队列获取-移除API"><a href="#阻塞队列获取-移除API" class="headerlink" title="阻塞队列获取/移除API"></a>阻塞队列获取/移除API</h3><p><img src="http://i3.itc.cn/20160907/aac_bc679be1_20f1_b35a_3ac8_6c05515fb314_1.png" alt=""></p>
<p>BlockingQueue阻塞队列提供了四种处理方法:</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th style="text-align:center">一直阻塞</th>
<th style="text-align:center">超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法(e)</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">put(e)</td>
<td style="text-align:center">offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take()</td>
<td style="text-align:center">poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>抛出异常</strong>：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li>
<li><strong>返回特殊值</strong>：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li>
<li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li>
<li><p><strong>超时退出</strong>：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</p>
<p>  放入数据：<br>  　　offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,<br>  　　　　则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）<br>  　　offer(E o, long timeout, TimeUnit unit),可以设定等待的时间，如果在指定的时间内，还不能往队列中<br>  　　　　加入BlockingQueue，则返回失败。<br>  　　put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断<br>  　　　　直到BlockingQueue里面有空间再继续.<br>  获取数据：<br>  　　poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,<br>  　　　　取不到时返回null;<br>  　　poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，<br>  　　　　队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。<br>  　　take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到<br>  　　　　BlockingQueue有新的数据被加入;<br>  　　drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数），<br>  　　　　通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。</p>
</li>
</ul>
<h3 id="LinkedBlockingQueue和ArrayBlockingQueue对比"><a href="#LinkedBlockingQueue和ArrayBlockingQueue对比" class="headerlink" title="LinkedBlockingQueue和ArrayBlockingQueue对比"></a>LinkedBlockingQueue和ArrayBlockingQueue对比</h3><p><code>linkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>比较：</p>
<pre><code>LinkedBlockingQueue是BlockingQueue的一种使用Link List的实现，它对头和尾（取和添加
操作）采用两把不同的锁，相对于ArrayBlockingQueue提高了吞吐量。它也是一种阻塞型的容
器，适合于实现“消费者生产者”模式。
ArrayBlockingQueue是对BlockingQueue的一个数组实现，它使用一把全局的锁并行对queue的
读写操作，同时使用两个Condition阻塞容量为空时的取操作和容量满时的写操作。
正因为LinkedBlockingQueue使用两个独立的锁控制数据同步，所以可以使存取两种操作并行执
行，从而提高并发效率。而ArrayBlockingQueue使用一把锁，造成在存取两种操作争抢一把锁，
而使得性能相对低下。LinkedBlockingQueue可以不设置队列容量，默认Integer.MAX_VALUE
其容易造成内存溢出，一般要设置其值。
</code></pre><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>   ArrayBlockingQueue一个由数组支持的<strong>有界的阻塞队列</strong>。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p>
<blockquote>
<p>源码</p>
</blockquote>
<pre><code>~~ java 基于 reetranLock锁 和 condition等待通知 实现

public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {

/** The queued items */
final Object[] items;

/** items index for next take, poll, peek or remove */
int takeIndex;

/** items index for next put, offer, or add */
int putIndex;

/** Number of elements in the queue */
int count;

/** Main lock guarding all access 用于阻塞其他线程 */
final ReentrantLock lock;
/** Condition for waiting takes   用于唤醒消费 */
private final Condition notEmpty;
/** Condition for waiting puts    用于唤醒生产 */
private final Condition notFull ;

/**
 * offer和poll一对，有返回值
 *
 * @throws NullPointerException if the specified element is null
 */
public boolean offer(E e) {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        if (count == items.length)
            return false;
        else {
            insert(e);//如果queue未满，添加元素，通知消费
            return true;
        }
    } finally {
        lock.unlock();
    }
}

 public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return (count == 0) ? null : extract();
    } finally {
        lock.unlock();
    }
}

/**
 *  put和take一对
 */
public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();    //可中断锁
    try {
        while (count == items.length)
            notFull.await();    //如果queue满了，就会阻塞&quot;放&quot;的过程
        insert(e);
    } finally {
        lock.unlock();
    }
}

public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0)
            notEmpty.await();    //如果queue为空，就会阻塞&quot;取&quot;的过程
        return extract();        //queue不为空，就释放notEmpty
    } finally {
        lock.unlock();
    }
}

/**
 * Inserts element at current put position, advances, and signals.
 * Call only when holding lock.
 */
private void insert(E x) {
    items[putIndex] = x;
    putIndex = inc(putIndex);
    ++count;
    notEmpty.signal();            // 等待生产&quot;放&quot;入元素，唤醒 队列为空 的阻塞线程进行消费
}

 /**
 * Extracts element at current take position, advances, and signals.
 * Call only when holding lock.
 */
private E extract() {
    final Object[] items = this.items;
    E x = this.&lt;E&gt;cast(items[takeIndex]);
    items[takeIndex] = null;
    takeIndex = inc(takeIndex);
    --count;
    notFull.signal();            // 等待消费&quot;取&quot;出元素，唤醒 队列为满 的阻塞线程进行生产
    return x;
}
</code></pre><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到<strong>最大值缓存容量</strong>时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>作为开发者，<strong>我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</strong>（如果 生产者速度&gt;消费速度 ，队列会持续增大，会撑爆jvm内存）</p>
<blockquote>
<p>源码</p>
</blockquote>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {

    /**
     * Linked list node class，内部类：定义一个节点
     */
    static class Node&lt;E&gt; {
        E item;

        /**
         * One of:
         * - the real successor Node
         * - this Node, meaning the successor is head.next
         * - null, meaning there is no successor (this is the last node)
         */
        Node&lt;E&gt; next;

        Node(E x) { item = x; }
    }

    /** The capacity bound, or Integer.MAX_VALUE if none */
    private final int capacity;

    /** Current number of elements */
    private final AtomicInteger count = new AtomicInteger(0);

    /**
     * Head of linked list.
     * Invariant: head.item == null
     */
    private transient Node&lt;E&gt; head;

    /**
     * Tail of linked list.
     * Invariant: last.next == null
     */
    private transient Node&lt;E&gt; last;

    /** Lock held by take, poll, etc &quot;取&quot;锁 */
    private final ReentrantLock takeLock = new ReentrantLock();

    /** Wait queue for waiting takes  消费者阻塞通知 */
    private final Condition notEmpty = takeLock.newCondition();

    /** Lock held by put, offer, etc  &quot;放&quot;锁 */
    private final ReentrantLock putLock = new ReentrantLock();

    /** Wait queue for waiting puts  生产者阻塞通知 */
    private final Condition notFull = putLock.newCondition();

    /**
    *   put和take一套，分别用独立锁，比arraylistBlockingQueue并发性能更好
    */
    public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    // Note: convention in all put/take/etc is to preset local var
    // holding count negative to indicate failure unless set.
    int c = -1;
    Node&lt;E&gt; node = new Node(e);
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        /*
         * Note that count is used in wait guard even though it is
         * not protected by lock. This works because count can
         * only decrease at this point (all other puts are shut
         * out by lock), and we (or some other waiting put) are
         * signalled if it ever changes from capacity. Similarly
         * for all other uses of count in other wait guards.
         */
        while (count.get() == capacity) {
            notFull.await();
        }
        enqueue(node);
        c = count.getAndIncrement();
        if (c + 1 &lt; capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
}

public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        while (count.get() == 0) {
            notEmpty.await();
        }
        x = dequeue();
        c = count.getAndDecrement();
        if (c &gt; 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    if (c == capacity)
        signalNotFull();
    return x;
}

/**
*  offer和poll是一对
*/
public boolean offer(E e) {
    if (e == null) throw new NullPointerException();
    final AtomicInteger count = this.count;
    if (count.get() == capacity)
        return false;
    int c = -1;
    Node&lt;E&gt; node = new Node(e);
    final ReentrantLock putLock = this.putLock;
    putLock.lock();
    try {
        if (count.get() &lt; capacity) {
            enqueue(node);
            c = count.getAndIncrement();
            if (c + 1 &lt; capacity)
                notFull.signal();
        }
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
    return c &gt;= 0;
}

 public E poll() {
    final AtomicInteger count = this.count;
    if (count.get() == 0)
        return null;
    E x = null;
    int c = -1;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        if (count.get() &gt; 0) {
            x = dequeue();
            c = count.getAndDecrement();
            if (c &gt; 1)
                notEmpty.signal();
        }
    } finally {
        takeLock.unlock();
    }
    if (c == capacity)
        signalNotFull();
    return x;
}

/**
 * Signals a waiting take. Called only from put/offer (which do not
 * otherwise ordinarily lock takeLock.)
 */
private void signalNotEmpty() {
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
}

/**
 * Signals a waiting put. Called only from take/poll.
 */
private void signalNotFull() {
    final ReentrantLock putLock = this.putLock;
    putLock.lock();
    try {
        notFull.signal();
    } finally {
        putLock.unlock();
    }
}
</code></pre><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue：是一个支持延时获取元素的使用优先级队列的实现的<strong>无界阻塞队列</strong>。队列中的元素必须实现Delayed接口和Comparable接口，也就是说DelayQueue里面的元素必须有public int compareTo( T o)和long getDelay(TimeUnit unit)方法存在，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：<br><strong>缓存系统的设计</strong>：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。<br><strong>定时任务调度</strong>。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。</p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue ：一个支持优先级排序的<strong>无界阻塞队列</strong>（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是<strong>PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="Excutor框架介绍"><a href="#Excutor框架介绍" class="headerlink" title="Excutor框架介绍"></a>Excutor框架介绍</h3><blockquote>
<p>任务的两级调度模型</p>
</blockquote>
<p><img src="http://i0.itc.cn/20160906/aac_74bb0904_12b6_7e23_00f8_d3d23eaabee0_3.png" alt=""></p>
<ul>
<li>任务：</li>
<li>任务的执行:包括任务执行机制的核心接口Executor和ExecutorService,Executor框架有两个关键类实现了ExecutorService接口(<strong>ThreadPoolExecutor、ScheduledThreadPoolExecutor</strong>)</li>
<li>异步计算的结果：包括接口future和实现Futrue接口的FutureTask类</li>
</ul>
<blockquote>
<p>类图：<br><img src="http://i0.itc.cn/20160906/aac_74bb0904_12b6_7e23_00f8_d3d23eaabee0_4.png" alt=""></p>
</blockquote>
<ul>
<li>Executor:定义的一个借口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。</li>
<li>ThreadPoolExecutor:线程池的核心实现类，用来执行被提交的任务。</li>
<li>ScheduledThreadPoolExecutor:是线程池的另外一个实现类，可以在给定延迟后运行命令或者定期执行命令，比Timer更灵活和强大。</li>
<li>Future/FutureTask ：一个是异步的接口，另外是一个异步的实现类，代表异步执行任务的方式。</li>
<li>Runnable/Callable:都是接口，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor作为任务去执行。</li>
</ul>
<blockquote>
<p>Executor使用示意图</p>
</blockquote>
<p><img src="http://i1.itc.cn/20160906/aac_74bb0904_12b6_7e23_00f8_d3d23eaabee0_5.png" alt=""></p>
<p>1).主线程首先创建实现Runnable或Callable接口的任务对象</p>
<p>2).工具类Executors可以把Runnable对象封装为Callable对象</p>
<pre><code>public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) {
    if (task == null)
        throw new NullPointerException();
    return new RunnableAdapter&lt;T&gt;(task, result);
}

public static Callable&lt;Object&gt; callable(Runnable task) {
    if (task == null)
        throw new NullPointerException();
    return new RunnableAdapter&lt;Object&gt;(task, null);
}
</code></pre><p>3).也可以直接把Runnable对象直接交给ExecutorService执行。</p>
<pre><code>//直接实现Executor接口的execute方法
void execute(Runnable command);
</code></pre><p>4).页可以把Runnable对象或Callable对象提交给ExecutorService执行</p>
<pre><code>都是基于异步的实现：
&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);
&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);
Future&lt;?&gt; submit(Runnable task);    
</code></pre><ul>
<li>Executor/ExecutorService接口</li>
</ul>
<p><img src="http://i1.itc.cn/20160906/aac_bc4f391d_1e59_2cfb_7834_ab6a6b94d2f8_1.png" alt=""><br><img src="http://i1.itc.cn/20160906/aac_138a14d1_0623_8405_1f78_2367ea86ed24_1.png" alt=""></p>
<ul>
<li>Runnable接口</li>
</ul>
<p><img src="http://i1.itc.cn/20160906/aac_138a14d1_0623_8405_1f78_2367ea86ed24_3.png" alt=""></p>
<ul>
<li>Future/Callable接口</li>
</ul>
<p><img src="http://i2.itc.cn/20160906/aac_138a14d1_0623_8405_1f78_2367ea86ed24_4.png" alt=""></p>
<p><img src="http://i2.itc.cn/20160906/aac_138a14d1_0623_8405_1f78_2367ea86ed24_2.png" alt=""></p>
<p>源码可以逐一解读，了解设计和实现方式。</p>
<h3 id="ThreadPoolExecutor实现"><a href="#ThreadPoolExecutor实现" class="headerlink" title="ThreadPoolExecutor实现"></a>ThreadPoolExecutor实现</h3><p>线程池模型图：</p>
<p><img src="http://i2.itc.cn/20160630/aac_3fe63360_2218_b4e0_56d4_89a2c3216c58_2.png" alt="正常步骤"></p>
<blockquote>
<p>构造方法：</p>
</blockquote>
<pre><code>/**
 * Creates a new {@code ThreadPoolExecutor} with the given initial
 * parameters.
 *
 * @param corePoolSize: the number of threads to keep in the pool, even
 *        if they are idle, unless {@code allowCoreThreadTimeOut} is set
 *        【核心线程池的大小】
 * @param maximumPoolSize the maximum number of threads to allow in the
 *        pool【最大线程池大小】
 * @param keepAliveTime when the number of threads is greater than
 *        the core, this is the maximum time that excess idle threads
 *        will wait for new tasks before terminating.【线程空闲时存活时间】
 * @param unit the time unit for the {@code keepAliveTime} argument【时间单位】
 * @param workQueue the queue to use for holding tasks before they are
 *        executed.  This queue will hold only the {@code Runnable}
 *        tasks submitted by the {@code execute} method.【用来保存任务的工作队列】
 * @param threadFactory the factory to use when the executor
 *        creates a new thread【定义线程池相关信息】
 * @param handler the handler to use when execution is blocked
 *        because the thread bounds and queue capacities are reached
 *        【当线程池关闭或已经达到饱和时，所采用的拒绝策略】
 * @throws IllegalArgumentException if one of the following holds:&lt;br&gt;
 *         {@code corePoolSize &lt; 0}&lt;br&gt;      
 *         {@code keepAliveTime &lt; 0}&lt;br&gt; 
 *         {@code maximumPoolSize &lt;= 0}&lt;br&gt;
 *         {@code maximumPoolSize &lt; corePoolSize}
 * @throws NullPointerException if {@code workQueue}
 *         or {@code threadFactory} or {@code handler} is null
 */
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize &lt; 0 ||
        maximumPoolSize &lt;= 0 ||
        maximumPoolSize &lt; corePoolSize ||
        keepAliveTime &lt; 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
</code></pre><blockquote>
<p>使用方式：</p>
</blockquote>
<p>通常使用工厂类Executors来创建。创建类型以下三种：</p>
<ul>
<li><p>FixedThreadPool:创建固定线程数的线程池，适合于限制当前线程数量的应用场景，适用于负载比较重的服务器。</p>
<p>  <img src="http://i0.itc.cn/20160906/aac_bc4f391d_1e59_2cfb_7834_ab6a6b94d2f8_2.png" alt=""></p>
<pre><code>1).如果当前运行的线程数少于corePoolSize,怎创建新线程来执行任务。
2).在线程池完成预热之后(currentThreads==corePoolSize),则将任务加入LinkedBlockingQueue.
3).线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。

注：FixedThreadPool默认使用无界队列LinkedBlockingQueue，队列容量为Integer.MAX_VALUE 2的31次方,不会走默认拒绝策略。
</code></pre></li>
<li><p>SingleThreadPool:创建使用单个线程的线程池，适用于保证顺序的执行各个任务</p>
<p>  <img src="http://i1.itc.cn/20160906/aac_bc4f391d_1e59_2cfb_7834_ab6a6b94d2f8_3.png" alt=""></p>
<pre><code>注:默认也是使用无界队列，队列容量为Integer.MAX_VALUE 2的31次方，线程池核心数量和最大数量为1。
</code></pre></li>
<li><p>CachedThreadPool:创建一个无大小边界的线程池，适用于执行很多短期的异步任务小程序，适用于负载较轻的服务器。</p>
<p>  <img src="http://i3.itc.cn/20160906/aac_bc4f391d_1e59_2cfb_7834_ab6a6b94d2f8_4.png" alt=""></p>
<p>  1).首先执行SynchronousQueue.offer(Runnable task),如果当前maxPoolsize中有空闲线程执行SynchronousQueue.poll(KeepaliveTime,Timeunit),那么配对成功，主线程吧任务交给空闲线程去执行，否则执行步骤2).<br>  2）.当初始MaxPoolSize为空，没有空闲线程，这种情况threadPool会取创建一个新线程执行任务。<br>  3).在步骤2)中新创建的线程将任务执行完后，会执行SynchronousQueue.poll(KeepaliveTime,Timeunit)默认是等待60s,如果60s以内 提交了新任务，则由该线程继续执行，否则改空闲线程将终止。</p>
</li>
</ul>
<pre><code>注：CachedThreadPool的corePoolSize设置为0，即corePool为空；maxPoolSize设置
    为Integer.MAX_VALUE,即是无界的，keepalive设置60s,空闲线程超过60s将会被终
    止。CachedThreadPool使用的是没有容量的SynchronousQueue,存在一个问题：如果
    主线程提交任务的速度快于处理的速度，会使该线程池不断创建新线程。极端情况下回耗
    尽操作系统的cpu和内存资源。
</code></pre><blockquote>
<p>代码实现：</p>
</blockquote>
<pre><code>//1.创建线程数threads=10的固定线程池
ExecutorService fixThreadPool = Executors.newFixedThreadPool(10);
//内部实现
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
}

//2.创建单个线程的线程池
ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();
//内部实现
public static ExecutorService newSingleThreadExecutor() {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue&lt;Runnable&gt;()));
   }

//3.创建无边界大小的线程池
ExecutorService cachedThreadPool = Executors.newCachedThreadPool();
//内部实现
public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
}

//4.1 方式1：  调用execute 执行runnable任务
threadPoolExecutor.execute(new Runnable() {
    @Override public void run() {
        System.out.println(&quot;execute a new task&quot;);
    }
});
//4.2 方式2： 调用submit方法提交runnable任务
Future&lt;?&gt; futureTask = threadPoolExecutor.submit(new Runnable() {
    @Override public void run() {
        System.out.println(&quot;submit a new task&quot;);
    }
});
//System.out.println(&quot;future runnable:&quot;+futureTask.get());//调用返回
//4.3 方式3： 调用submit方法提交callable
Future&lt;Object&gt; cFuture = threadPoolExecutor.submit(new Callable&lt;Object&gt;() {
    //回调函数
    @Override public Object call() throws Exception {
        return 1;
    }
});
System.out.println(&quot;future callable:&quot;+cFuture.get());
</code></pre><blockquote>
<p>饱和策略的默认四种实现:</p>
</blockquote>
<ul>
<li>AbortPolicy:直接抛出异常</li>
<li>CallerRunsPolicy:只用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy:丢弃队列里的最近的一个任务，并执行当前任务</li>
<li><p>DiscardPolicy:不处理直接丢弃掉。</p>
<p>  饱和策略源码：</p>
<pre><code>public static class CallerRunsPolicy implements RejectedExecutionHandler {
    /**
     * Creates a {@code CallerRunsPolicy}.
     */
    public CallerRunsPolicy() { }

    /**
     * Executes task r in the caller&apos;s thread, unless the executor
     * has been shut down, in which case the task is discarded.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 用当前线程来执行调用任务
        if (!e.isShutdown()) {
            r.run();
        }
    }
}

/**
 * A handler for rejected tasks that throws a
 * {@code RejectedExecutionException}.
 */
public static class AbortPolicy implements RejectedExecutionHandler {
    /**
     * Creates an {@code AbortPolicy}.
     */
    public AbortPolicy() { }

    /**
     * Always throws RejectedExecutionException.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     * @throws RejectedExecutionException always.
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 直接抛出拒绝的异常                
        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                                             &quot; rejected from &quot; +
                                             e.toString());
    }
}

/**
 * A handler for rejected tasks that silently discards the
 * rejected task.
 */
public static class DiscardPolicy implements RejectedExecutionHandler {
    /**
     * Creates a {@code DiscardPolicy}.
     */
    public DiscardPolicy() { }

    /**
     * Does nothing, which has the effect of discarding task r.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 不做任何处理，直接丢弃掉
    }
}

/**
 * A handler for rejected tasks that discards the oldest unhandled
 * request and then retries {@code execute}, unless the executor
 * is shut down, in which case the task is discarded.
 */
public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    /**
     * Creates a {@code DiscardOldestPolicy} for the given executor.
     */
    public DiscardOldestPolicy() { }

    /**
     * Obtains and ignores the next task that the executor
     * would otherwise execute, if one is immediately available,
     * and then retries execution of task r, unless the executor
     * is shut down, in which case task r is instead discarded.
     *
     * @param r the runnable task requested to be executed
     * @param e the executor attempting to execute this task
     */
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // 丢弃队列里最近的一个任务，并执行当前任务
        if (!e.isShutdown()) {
            e.getQueue().poll();
            e.execute(r);
        }
    }
}
</code></pre></li>
</ul>
<h3 id="ScheduledThreadPoolExecutor实现"><a href="#ScheduledThreadPoolExecutor实现" class="headerlink" title="ScheduledThreadPoolExecutor实现"></a>ScheduledThreadPoolExecutor实现</h3><p>执行流程图：<br><img src="http://i3.itc.cn/20160906/aac_93869b23_171e_f5c7_b916_e769d4391ef7_1.png" alt=""></p>
<p>ScheduledThreadPoolExecutor使用的是DelayQueue,其中DelayQueue是一个无界队列，所以MaxPoolSize没有什么意义，执行任务分两部分：</p>
<ul>
<li><p>调用scheduleWithFixedDelay或scheduleAtFixedRate方法 向DelayQueue添加一个延时的任务</p>
<pre><code>/**
 * command :执行的任务
 * initialDelay:开始计时时间
 * delay:延迟执行时间
 * unit：时间单位
 */
public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,
                                             long initialDelay,
                                             long delay,
                                             TimeUnit unit) {}
</code></pre></li>
<li><p>线程池中线程从DelayQueue中获取SchduledFutureTask,然后执行任务。</p>
</li>
<li><p>延时执行 通过future异步机制实现。</p>
<pre><code>//5.执行定时任务的线程池
ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(10);
scheduledThreadPoolExecutor.scheduleWithFixedDelay(new Runnable() {
    @Override public void run() {
        System.out.println(&quot;schdule a task&quot;);
    }
},2,5,TimeUnit.SECONDS);
</code></pre></li>
</ul>
<h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>FutureTask除了实现Future接口还实现了Runnable接口，因此 既可以交给Executor执行也可以有FutrueTask.run（）去执行。</p>
<p>FutureTask状态变更：<br><img src="http://i3.itc.cn/20160906/aac_93869b23_171e_f5c7_b916_e769d4391ef7_2.png" alt=""></p>
<ul>
<li>当未启动：执行FutureTask.get()会导致调用线程阻塞；执行cancel()将导致任务用于不会被执行；</li>
<li>已启动状态：执行FutureTask.get()会导致调用线程阻塞；执行cancel(true)将试图中断执行任务线程 ；执行cancel(false)不会对线程产生影响</li>
<li>已完成状态：执行FutureTask.get()将导致调用线程立即返回结果或者抛出异常；执行cancel（）将返回false.</li>
</ul>
<p>FutureTask执行示意图：<br><img src="http://i1.itc.cn/20160906/aac_93869b23_171e_f5c7_b916_e769d4391ef7_3.png" alt=""></p>
<h2 id="JDK相关类"><a href="#JDK相关类" class="headerlink" title="JDK相关类"></a>JDK相关类</h2><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><pre><code>Lock (java.util.concurrent.locks)
    ReadLock in ReentrantReadWriteLock (java.util.concurrent.locks)
    ReentrantLock (java.util.concurrent.locks)
    WriteLock in ReentrantReadWriteLock (java.util.concurrent.locks)


成员方法：
    lock()
    lockInterruptibly()
    tryLock()
    tryLock()
    unlock()
    newCondition()
</code></pre><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p> lockSupport工具静态方法:</p>
<pre><code>unpark(Thread) 
park(Object)
parkNanos(Object, long)
parkUntil(Object, long)
park()
parkNanos(long)
parkUntil(long) 
</code></pre><p><img src="http://i1.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_3.png" alt="Locksupport阻塞和唤醒方法"></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>ThreadLocal，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。可能很多朋友都知道ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。</p>
<blockquote>
<p>数据结构：</p>
</blockquote>
<p>通过其内部类ThreadLocalMap 作为其存储结构，类似Map的数据结构存储 键-值 对。</p>
<p>~~ java</p>
<pre><code> //Thread持有THreadLocals的引用
 public class Thread implements Runnable {
    ThreadLocal.ThreadLocalMap threadLocals = null;
 }

// ThreadLocal
 public class ThreadLocal&lt;T&gt; {
     static class ThreadLocalMap {

        private Entry[] table;

        static class Entry extends WeakReference&lt;ThreadLocal&gt; {
                /** The value associated with this ThreadLocal. */
                Object value;

                Entry(ThreadLocal k, Object v) {
                    super(k);
                    value = v;
                }
        }

        //构造方法
        ThreadLocalMap(ThreadLocal firstKey, Object firstValue) {
                table = new Entry[INITIAL_CAPACITY];
                int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);
                table[i] = new Entry(firstKey, firstValue);
                size = 1;
                setThreshold(INITIAL_CAPACITY);
        }
    }
}
</code></pre><blockquote>
<p>ThreadLocal类提供的几个方法:</p>
</blockquote>
<pre><code>public T get() { }
public void set(T value) { }
public void remove() { }
protected T initialValue() { }  //懒加载
</code></pre><p>get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法。</p>
<p>可参考：<a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3920407.html</a></p>
<h3 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h3><p>包名：sun.misc.Unsafe</p>
<p>提供了可以随意查看及修改JVM中运行时的数据结构，尽管这些功能在JAVA开发本身是不适用的，Unsafe是一个用于研究学习HotSpot虚拟机非常棒的工具，因为它不需要调用C++代码，或者需要创建即时分析的工具。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>AQS同步工具对比：<a href="http://yanan0628.iteye.com/blog/2322683" target="_blank" rel="external">http://yanan0628.iteye.com/blog/2322683</a><br>并发编程网：<a href="http://ifeve.com/abstractqueuedsynchronizer-use/" target="_blank" rel="external">http://ifeve.com/abstractqueuedsynchronizer-use/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/01/(7.2).分布式架构-hystrix/" itemprop="url">
                  hystrix线程池隔离
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-01T10:56:40+08:00" content="2016-06-01">
              2016-06-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/线程池隔离/" itemprop="url" rel="index">
                    <span itemprop="name">线程池隔离</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>##为什么要用hystrix?    </p>
<p>##如何解决依赖隔离</p>
<pre><code>1:Hystrix使用命令模式HystrixCommand(Command)包装依赖调用逻辑，每个命令在单独线程中/信号授权下执行。
2:可配置依赖调用超时时间,超时时间一般设为比99.5%平均时间略高即可.当调用超时时，直接返回或执行fallback逻辑。
3:为每个依赖提供一个小的线程池（或信号），如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。
4:依赖调用结果分:成功，失败（抛出异常），超时，线程拒绝，短路。 请求失败(异常，拒绝，超时，短路)时执行fallback(降级)逻辑。
5:提供熔断器组件,可以自动运行或手动调用,停止当前依赖一段时间(10秒)，熔断器默认错误率阈值为50%,超过将自动运行。
6:提供近实时依赖的统计和监控
</code></pre>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/01/(7.2).分布式架构-hystrix/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/03/(5.3).server-nginx/" itemprop="url">
                  nginx
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-03T10:52:03+08:00" content="2016-05-03">
              2016-05-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/server/" itemprop="url" rel="index">
                    <span itemprop="name">server</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/02/(5.2).web-logback/" itemprop="url">
                  logback使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-02T10:52:03+08:00" content="2016-05-02">
              2016-05-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h3><h4 id="logback配置解析"><a href="#logback配置解析" class="headerlink" title="logback配置解析"></a>logback配置解析</h4><blockquote>
<p>线上配置文件</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot;?&gt;
&lt;!--
  Example LOGBACK Configuration File
  http://logback.qos.ch/manual/configuration.html
  --&gt;
&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;30 seconds&quot; debug=&quot;false&quot;&gt;

    &lt;contextName&gt;${proojectName}&lt;/contextName&gt;

    &lt;!--  console --&gt;
    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS}-[%thread] %-5level %logger{60}[%line] - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;appender name=&quot;FILE-INFO&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
         &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;INFO&lt;/level&gt;
        &lt;/filter&gt;
        &lt;file&gt;${stdout.log}&lt;/file&gt;

        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;${stdout.log}.%d{yyyy-MM-dd}&lt;/fileNamePattern&gt;
            &lt;maxHistory&gt;${log.maxnum}&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS}-[%thread] %-5level %logger{60}[%line] - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;appender name=&quot;FILE-ERROR&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;ERROR&lt;/level&gt;
        &lt;/filter&gt;
        &lt;file&gt;${stderr.log}&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;${stderr.log}.%d{yyyy-MM-dd}&lt;/fileNamePattern&gt;
            &lt;maxHistory&gt;${log.maxnum}&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{60}[%line] - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!-- build log --&gt;
    &lt;appender name=&quot;Builder&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;

        &lt;file&gt;${build.log}&lt;/file&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;${build.log}.%d{yyyy-MM-dd}&lt;/fileNamePattern&gt;
            &lt;maxHistory&gt;${log.maxnum}&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{60}[%line] - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;logger name=&quot;com.sohu.tv.cms.builder&quot; level=&quot;DEBUG&quot; addtivity=&quot;true&quot;&gt;
        &lt;appender-ref ref=&quot;Builder&quot;/&gt;
    &lt;/logger&gt;

    &lt;root level=&quot;${log.level}&quot;&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;
        &lt;appender-ref ref=&quot;FILE-INFO&quot;/&gt;
        &lt;appender-ref ref=&quot;FILE-ERROR&quot;/&gt;
    &lt;/root&gt;

&lt;/configuration&gt;
</code></pre><blockquote>
<p>元素</p>
</blockquote>
<ul>
<li><p>根节点 configuration</p>
<pre><code>scan:
当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
scanPeriod:
设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。
debug:
当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。

例如： 
&lt;configuration scan=&quot;true&quot; scanPeriod=&quot;60 seconds&quot; debug=&quot;false&quot;&gt;  
      &lt;!-- 其他配置省略--&gt;  
&lt;/configuration&gt; 
</code></pre></li>
<li><p>appender/logger/root子节点</p>
<p>  <img src="http://logback.qos.ch/manual/images/chapters/configuration/basicSyntax.png" alt=""></p>
<ul>
<li><p>logger节点    </p>
<pre><code>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定&lt;appender&gt;。&lt;loger&gt;仅有一个name属性，一个可选的level和一个可选的addtivity属性。
name:
用来指定受此loger约束的某一个包或者具体的某一个类。
level:
用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。
如果未设置此属性，那么当前loger将会继承上级的级别。
addtivity:
是否向上级loger传递打印信息。默认是true。
&lt;loger&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个loger。
</code></pre></li>
<li><p>root节点</p>
<pre><code>也是&lt;loger&gt;元素，但是它是根loger。只有一个level属性，应为已经被命名为&quot;root&quot;.
level:
用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。
默认是DEBUG。
&lt;root&gt;可以包含零个或多个&lt;appender-ref&gt;元素，标识这个appender将会添加到这个loger。
</code></pre></li>
<li><p>appender节点</p>
<p>  <img src="http://logback.qos.ch/manual/images/chapters/configuration/appenderSyntax.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<p>appender是configuration的子节点，是负责写日志的组件。<br>appender有两个必要属性name和class。name指定appender名称，class指定appender的全限定名。</p>
<blockquote>
<p>ConsoleAppender:</p>
</blockquote>
<p><strong>输出到日志添加到控制台</strong>，有以下子节点：</p>
<p><encoder>：对日志进行格式化。（具体参数稍后讲解 ）</encoder></p>
<p><target>：字符串 System.out 或者 System.err ，默认 System.out ；</target></p>
<pre><code>&lt;configuration&gt;  

  &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;  
    &lt;encoder&gt;  
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg %n&lt;/pattern&gt;  
    &lt;/encoder&gt;  
  &lt;/appender&gt;  

  &lt;root level=&quot;DEBUG&quot;&gt;  
    &lt;appender-ref ref=&quot;STDOUT&quot; /&gt;  
  &lt;/root&gt;  
&lt;/configuration&gt; 
</code></pre><blockquote>
<p>FileAppender</p>
</blockquote>
<p><strong>输出到日志添加到文件</strong>，有以下子节点：</p>
<pre><code>&lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。
&lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。
&lt;encoder&gt;：对记录事件进行格式化。（具体参数稍后讲解 ）
&lt;prudent&gt;：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。

&lt;configuration&gt;  

  &lt;appender name=&quot;FILE&quot; class=&quot;ch.qos.logback.core.FileAppender&quot;&gt;  
    &lt;file&gt;testFile.log&lt;/file&gt;  
    &lt;append&gt;true&lt;/append&gt;  
    &lt;encoder&gt;  
      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;  
    &lt;/encoder&gt;  
  &lt;/appender&gt;  

  &lt;root level=&quot;DEBUG&quot;&gt;  
    &lt;appender-ref ref=&quot;FILE&quot; /&gt;  
  &lt;/root&gt;  
&lt;/configuration&gt; 
</code></pre><blockquote>
<p>RollingFileAppender:</p>
</blockquote>
<p><strong>输出到滚动记录文件</strong>，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子节点：</p>
<pre><code>&lt;file&gt;：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。
&lt;append&gt;：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。
&lt;encoder&gt;：对记录事件进行格式化。（具体参数稍后讲解 ）
&lt;rollingPolicy&gt;:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。
&lt;triggeringPolicy &gt;: 告知 RollingFileAppender 合适激活滚动。
&lt;prudent&gt;：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。

-----------------------------------------------------------------------------
rollingPolicy:
    TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。
    FixedWindowRollingPolicy： 根据固定窗口算法重命名文件的滚动策略

encoder：
    负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。
    目前PatternLayoutEncoder 是唯一有用的且默认的encoder ，有一个&lt;pattern&gt;节点，
    用来设置日志的输入格式。使用“%”加“转换符”方式，如果要输出“%”，则必须用“\”对“\%”进行转义。

例如：
&lt;encoder&gt;   
   &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;   
&lt;/encoder  
</code></pre><h4 id="logback类图"><a href="#logback类图" class="headerlink" title="logback类图"></a>logback类图</h4><p><img src="http://dl2.iteye.com/upload/attachment/0055/5497/91743e11-7bbb-38d5-b7a0-0501a65968a6.jpg" alt="logback类图"></p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>博客：<a href="http://blog.csdn.net/haidage/article/details/6794509" target="_blank" rel="external">http://blog.csdn.net/haidage/article/details/6794509</a><br>博客：<a href="http://czj4451.iteye.com/blog/1984259" target="_blank" rel="external">http://czj4451.iteye.com/blog/1984259</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/01/(5.1).web-字符编码/" itemprop="url">
                  字符集编码
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-01T10:52:03+08:00" content="2016-05-01">
              2016-05-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>###1.编码分类</p>
<ul>
<li><p>1.1 字符集分类：<br><img src="http://i1.itc.cn/20160616/aac_ff3ab3f1_04c2_1ae6_a39b_1d639335f328_2.jpg" alt="字符集"></p>
<pre><code>ISO-8859-1：是四方国家所使用的编码机，单字节的字符集。
Unicode ：一种通用字符集，每个字符都用2个字节来表示，对于英文字符采用前面补0的
           方法实现等长兼容。
GB2312：GB2312是中国国家标准的简体中文字符集。它所收录的汉字已经覆盖99.75%
            的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。
GBK：  除了完全兼容GB2312之外，还对繁体中文，不常用汉字和特殊符号进行了编码。
UTF-8：UTF-8便于不同的计算机之间使用网络传输不同语言和编码的文字，使得双字节的
       Unicode能够在现存的处理单字节的系统上正确传输。UTF-8使用可变长度字节来储
       存 Unicode字符，例如ASCII字母继续使用1字节储存，重音文字、希腊字母或西里
       尔字母等使用2字节来储存，而常用的汉字就要使用3字节。辅助平面字符则使用4字节。
</code></pre></li>
</ul>
<p>IO流(流写入/写出文件时)<br>操作系统(windows/liunx差异)<br>jvm，server</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/01/(5.1).web-字符编码/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/05/01/(1.1).markdown模板/" itemprop="url">
                  markdown样例模板
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-05-01T00:00:00+08:00" content="2016-05-01">
              2016-05-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/markdown/" itemprop="url" rel="index">
                    <span itemprop="name">markdown</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://www.zybuluo.com/mdeditor" title="作业部落旗下 Cmd 在线 Markdown 编辑阅读器" target="_blank" rel="external">『Cmd 技术渲染的沙箱页面，点击此处编写自己的文档』</a></p>
<h1 id="Cmd-Markdown-简明语法手册"><a href="#Cmd-Markdown-简明语法手册" class="headerlink" title="Cmd Markdown 简明语法手册"></a>Cmd Markdown 简明语法手册</h1><p>标签： Cmd-Markdown</p>
<hr>
<h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 <em> 和 *</em> 表示斜体和粗体。</p>
<p>示例：</p>
<p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p>
<h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">这是一个一级标题</div><div class="line">============================</div><div class="line"></div><div class="line">这是一个二级标题</div><div class="line">--------------------------------------------------</div><div class="line"></div><div class="line">### 这是一个三级标题</div></pre></td></tr></table></figure>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/05/01/(1.1).markdown模板/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/02/(4.1).mysql-索引及B+树/" itemprop="url">
                  mysql索引介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-02T16:57:26+08:00" content="2016-04-02">
              2016-04-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="1-第一部分"><a href="#1-第一部分" class="headerlink" title="1.第一部分"></a>1.第一部分</h2><h3 id="1-1-mysql存储引擎"><a href="#1-1-mysql存储引擎" class="headerlink" title="1.1.mysql存储引擎"></a>1.1.mysql存储引擎</h3><p>   <img src="http://i1.itc.cn/20160505/aac_2190e510_9e21_5fc9_e81f_8bff6e43f346_3.PNG" alt="二叉树结构"></p>
<h3 id="1-2-B-树数据结构"><a href="#1-2-B-树数据结构" class="headerlink" title="1.2.B+树数据结构"></a>1.2.B+树数据结构</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Random;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BplusTree</span> <span class="keyword">implements</span> <span class="title">B</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">/** 根节点 */</span></div><div class="line"><span class="keyword">protected</span> Node root;</div><div class="line"></div><div class="line"><span class="comment">/** 阶数，M值 */</span></div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> order;</div><div class="line"></div><div class="line"><span class="comment">/** 叶子节点的链表头*/</span></div><div class="line"><span class="keyword">protected</span> Node head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/04/02/(4.1).mysql-索引及B+树/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/01/(4.2).mysql-事务/" itemprop="url">
                  mysql锁和事务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-01T16:57:26+08:00" content="2016-04-01">
              2016-04-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="mysql的并发控制"><a href="#mysql的并发控制" class="headerlink" title="mysql的并发控制"></a>mysql的并发控制</h2><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>锁时数据库系统区别于文件系统的一个关键特性，锁机制用于管理对共享资源的并发访问。数据库使用锁是为了对共享资源并发访问，提供数据的完整性和一致性。</p>
<blockquote>
<p>锁的粒度</p>
</blockquote>
<p>Myisam表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。<br>Innodb行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<h3 id="innodb锁的类型"><a href="#innodb锁的类型" class="headerlink" title="innodb锁的类型"></a>innodb锁的类型</h3><p>Innodb存储引擎实现了两种标准的行级锁：</p>
<ul>
<li>共享锁(S lock):允许事务读一行数据</li>
<li>排它锁(X lock):允许事务删除或更新一行数据</li>
</ul>
<p><strong>锁兼容</strong>：如果一个事务已经获得行r的共享锁，那么另外的事务可以立即获得行r的共享锁<br><strong>锁冲突</strong>：如果一个事务想获取行r的排它锁，则它必须等待事务释放行r的共享锁</p>
<p>共享锁(S)和排它锁（X）兼容性：</p>
<h3 id="锁的算法"><a href="#锁的算法" class="headerlink" title="锁的算法"></a>锁的算法</h3><ul>
<li>Record Lock：单个行记录上的锁</li>
<li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身</li>
<li>Next-key Lock:Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身</li>
</ul>
<p>Record Lock总是会去锁住索引记录，如果InnoDB存储引擎表建立的时候没有设置任何一个索引，这时InnodB存储引擎会使用隐式的主键来进行锁定，在Repeatable Read隔离级别下，Next-key Lock 算法是默认的行记录锁定算法。</p>
<h3 id="锁的问题"><a href="#锁的问题" class="headerlink" title="锁的问题"></a>锁的问题</h3><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>如何避免丢失更新：让事务变成串行操作，而不是并发的操作，即对每个事务开始—对读取记录加排他锁。</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>脏读即一个事务可以读到另一个事务中未提交的数据，这违反了数据库的隔离性。<br>脏读发生的条件是需要事务的隔离级别为Read uncommitted。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>不可重复读与脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的是已经提交的数据。<br>一般来说，不可重复读是可以接受的，在InnoDB存储引擎中，通过使用Next-Key Lock算法来避免不可重复读的问题。</p>
<h3 id="死锁的相关问题"><a href="#死锁的相关问题" class="headerlink" title="死锁的相关问题"></a>死锁的相关问题</h3><h4 id="死锁发生条件"><a href="#死锁发生条件" class="headerlink" title="死锁发生条件"></a>死锁发生条件</h4><p>互斥条件：一个资源每次只能被一个进程使用；请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><h4 id="死锁解决"><a href="#死锁解决" class="headerlink" title="死锁解决"></a>死锁解决</h4><p>1)先执行show processlist找到死锁线程号.然后Kill pid<br>2)Show innodb status检查引擎状态 ,可以看到哪些语句产生死锁<br>3)查看information_schema架构下的innodb_locks、innodb_trx、innodb_lock_waits等表</p>
<h2 id="mysql的事务"><a href="#mysql的事务" class="headerlink" title="mysql的事务"></a>mysql的事务</h2><h3 id="事务ACID四大特性"><a href="#事务ACID四大特性" class="headerlink" title="事务ACID四大特性"></a>事务ACID四大特性</h3><pre><code>Atomicity  原子性：执行每次操作时原子的，对于数据的修改 要么做 要么不做
Consistent 一致性：在事务的开始和结束，数据都必须保证一致的状态
Isolation  隔离性：通过事务隔离级别来控制，保证事务不受多线程环境影响
Durablity  持久性：事务完成之后，它对于数据的落地是永久的，及时机械故障也不影响
</code></pre><p>为了更好地理解ACID，以银行账户转账为例：</p>
<pre><code>1 START TRANSACTION;        
2 SELECT balance FROM checking WHERE customer_id = 10233276;
3 UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276;
4 UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276;
5 COMMIT;

原子性：要么完全提交（10233276的checking余额减少200，savings 的余额增加200），
       要么完全回滚（两个表的余额都不发生变化）

一致性：这个例子的一致性体现在 200元不会因为数据库系统运行到第3行之后，第4行之前
       时崩溃而不翼而飞，因为事物还没有提交。

隔离性：允许在一个事务中的操作语句会与其他事务的语句隔离开，比如事务A运行到第3行
       之后，第4行之前，此时事务B去查询checking余额时，它仍然能够看到在事务A中
       被减去的200元，因为事务A和B是彼此隔离的。在事务A提交之前，事务B观察不到数据的改变。

持久性：这个很好理解。
</code></pre><h3 id="事务的隔离机制"><a href="#事务的隔离机制" class="headerlink" title="事务的隔离机制"></a>事务的隔离机制</h3><p><img src="http://i3.itc.cn/20160903/aac_bd142760_b62d_f037_eae8_19ea652e5c1c_1.png" alt=""></p>
<ul>
<li><p>未提交读</p>
<p>  事务中的修改即使没有提交，也对其他事务是可见的。当事务读取到未提交的数据时成脏读（Dirty Read）。优点不明显，但却具备其他隔离级别的缺点。</p>
</li>
<li><p>提交读</p>
<p>  大多数数据库系统的默认隔离级别（但mysql不是）。它满足隔离性简单要求，只能看见已经提交事务的修改，但是不可重复读（nonrepeatable read），两次执行统一的查询，可能得到不同的结果，因为执行过程中可能有其他事务提交结果。在RC级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。</p>
</li>
<li><p>可重复读</p>
<p>  保证在同一个事务中多次读取结果一致。这是mysql默认的事务隔离级别。会产生幻读（Phantom Read），在范围读取时，读取到其他事务插入的数据。不可重复读在于update和delete，而幻读在于insert。需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。</p>
<p>  为解决幻读问题，大多数事务型存储引擎实现的都不是简单的行级锁，基于提升性能考虑，使用基于乐观锁为理论基础实现的多版本并发控制（MVCC），它是行级锁的变种，在很多情况下避免了加锁操作，因此开销更低。因为MVCC没有统一的标准，所以各自的实现机制不尽相同。实现非阻塞的读操作，写操作只锁定必要的行。</p>
</li>
</ul>
<blockquote>
<p>不同级别隔离产生数据的现象：</p>
</blockquote>
<ul>
<li>脏读：<strong>一个事务修改了数据 但是为提交，另一个事务能读到这条数据的变更。</strong></li>
<li>不重复读：<strong>解决脏读问题后，如果一个 事务修改了数据 ，并最终提交，另外一个事务 在前一个事务提交前后，读取到两次数据结构不一致。</strong></li>
<li>幻读：<strong>解决了不重复读问题，保证同一个事务开启到结束，查询的结果都是事务开始时的状态（一致性）。但是，如果另一个事务同时提交了新数据，本事务再更新时，就会“惊奇的”发现了这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。</strong></li>
</ul>
<blockquote>
<p>mysql设置和查看四种隔离级别</p>
</blockquote>
<pre><code>set tx_isolation=&apos;read-uncommitted&apos;; //设置未提交读
set tx_isolation=&apos;read-committed&apos;;     //设置已提交读
set tx_isolation=&apos;repeatable-read&apos;;     //设置可重复读
set tx_isolation=&apos;serializable&apos;;     //序列化

select @@tx_isolation;        //查看当前锁力度

    +----------------+
    | @@tx_isolation |
    +----------------+
    | READ-COMMITTED |
    +----------------+
    1 row in set
</code></pre><blockquote>
<p>四种隔离级别效果演示：</p>
</blockquote>
<p>表和数据准备：</p>
<pre><code>创建表：
create table a (id int,num int not null,primary key(id)) engine=innodb;

insert into a values (1,1);
insert into a values (2,2);
insert into a values (3,3);

mysql&gt; select * from a;
+----+-----+
| id | num |
+----+-----+
|  1 |   1 |
|  2 |   2 |
|  3 |   3 |
+----+-----+
3 rows in set (0.04 sec)
</code></pre><ul>
<li>未提交读 read-uncommitted</li>
</ul>
<p><img src="http://i2.itc.cn/20160903/aac_d27560e6_8143_f9df_89cc_c9c0628819a8_1.png" alt="">    </p>
<ul>
<li>已提交读 read-commmitted</li>
</ul>
<p><img src="http://i0.itc.cn/20160903/aac_d27560e6_8143_f9df_89cc_c9c0628819a8_2.png" alt=""></p>
<ul>
<li>可重复读 read-committed</li>
</ul>
<p><img src="http://i1.itc.cn/20160903/aac_d27560e6_8143_f9df_89cc_c9c0628819a8_4.png" alt=""><br><img src="http://i3.itc.cn/20160903/aac_d27560e6_8143_f9df_89cc_c9c0628819a8_3.png" alt=""></p>
<p>出现“幻读”现象：<br><img src="http://i2.itc.cn/20160903/aac_29d41106_846b_6bc8_eb31_0b87fa7386c3_1.png" alt=""></p>
<ul>
<li>串行化<br><img src="http://i0.itc.cn/20160903/aac_29d41106_846b_6bc8_eb31_0b87fa7386c3_2.PNG" alt=""></li>
</ul>
<h3 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h3><p>InnoDB的简化版行为说明MVCC：在每行记录后面保存两个隐藏的列，一个保存行的创建时间一个保存行的删除时间，时间为系统的版本号，每开始一个新的事务，系统版本号就自动递增。</p>
<p>SELECT</p>
<p>InnoDB只查找版本小于等于当前版本号的数据行，这样可以保证事务读取的行，要么是之前已经存在的要么是自身插入或修改的<br>行的删除版本要么未定义，要么大于当前版本号。这可以确保数据行在事务开始前未被删除。<br>两者都满足，返回的是事务开始之前（或自己插入修改的）已经存在的数据且还没有被删除的。保证不会出现脏读、不可重复读和幻读。</p>
<p>INSERT</p>
<p>为插入的每一行保存当前系统版本号。</p>
<p>DELETE</p>
<p>为删除的每一行保存删除版本号。</p>
<p>UPDATE</p>
<p>插入一行新纪录，保存当前版本号；同时保存当前系统版本号到原来的行作为删除版本号。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>mysql幻读：<a href="http://www.bitscn.com/pdb/mysql/201405/227973.html" target="_blank" rel="external">http://www.bitscn.com/pdb/mysql/201405/227973.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/05/(3.2).java-算法/" itemprop="url">
                  java-算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-05T00:00:00+08:00" content="2016-03-05">
              2016-03-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/数据结构，java算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构，java算法</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p><img src="http://i0.itc.cn/20160907/aac_338355ab_1049_a692_3a97_694f20f4ea50_1.png" alt=""></p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>基本思想：遍历数组过程中，以i代表当前排序序号，则需要在剩下的[i,n-1]中找出其最小值，然后将该最小值 与 i指向的位置交换。每一趟决定一个最小值。</p>
<p>时间复杂度：o(n2)<br>空间复杂度:o(1)</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>基本思想:两层for循环，从数组最后一个位置开始两两比较交换，如果相邻两个元素是否逆序，是的话则交换，外层循环一次就能将数组中剩下的最小元素“浮”到最前面。</p>
<p>时间复杂度：o(n2)<br>空间复杂度:o(1)</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>基本思想：在遍历数组的过程中，假设在序号i之前的元素即[0,i-1]都已经排好序，本趟需要找到对应i位置对应元素x的正确位置，并且在寻找过程中逐个将比较过的元素往后移动一位，为元素x腾出位置。每一趟决定任意一个元素的位置。</p>
<p>时间复杂度：o(n2)<br>空间复杂度：o(1)</p>
<h3 id="希尔排序？"><a href="#希尔排序？" class="headerlink" title="希尔排序？"></a>希尔排序？</h3><p>基本思想:希尔排序的<strong>诞生是由于插入排序在处理大规模数组的时候会遇到需要移动太多元素的问题</strong>。希尔排序的思想是将一个大的数组“分而治之”，划分为若干个小的数组，以 gap 来划分，比如数组 [1, 2, 3, 4, 5, 6, 7, 8] ，如果以 gap = 2 来划分，可以分为 [1, 3, 5, 7] 和 [2, 4, 6, 8] 两个数组（对应的，如 gap = 3 ，则划分的数组为： [1, 4, 7] 、 [2, 5, 8] 、 [3, 6] ）然后分别对划分出来的数组进行插入排序，待各个子数组排序完毕之后再减小 gap 值重复进行之前的步骤，直至 gap = 1 ，即对整个数组进行插入排序，此时的数组已经基本上快排好序了，所以需要移动的元素会很小很小，解决了插入排序在处理大规模数组时较多移动次数的问题。</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>基本思想：归并排序采用的是递归来实现，属于“分而治之”，将目标数组从中间一分为二，之后分别对这两个数组进行排序，排序完毕之后再将排好序的两个数组“归并”到一起，归并排序最重要的也就是这个“归并”的过程，归并的过程中需要额外的跟需要归并的两个数组长度一致的空间。</p>
<pre><code>1）将两个子数组中的元素复制到新数组 copiedArray 中，以前面提到的例子为例，则 copiedArray = [3, 6, 8, 11, 1, 3, 12, 15] ；
2） 设置两个指针分别指向原子数组中对应的第一个元素，假定这两个指针取名为 leftIdx 和 rightIdx ，则 leftIdx = 0 （对应 copiedArray 中的第一个元素 [3] ）， rightIdx = 4 （对应 copiedArray 中的第五个元素 [1] ）；
3） 比较 leftIdx 和 rightIdx 指向的数组元素值，选取其中较小的一个并将其值赋给原数组中对应的位置 i ，赋值完毕后分别对参与赋值的这两个索引做自增 1 操作，如果 leftIdx 或 rigthIdx 值已经达到对应数组的末尾，则余下只需要将剩下数组的元素按顺序 copy 到余下的位置即可。
下面给个归并的具体实例：

第一趟：    
辅助数组 [21 , 28, 39 | 35, 38] （数组被拆分为左右两个子数组，以 | 分隔开）    
[21 ,  ,  ,  ,  ] （第一次 21 与 35 比较 , 左边子数组胜出， leftIdx = 0 ， i = 0 ）    
第二趟：    
辅助数组 [21, 28 , 39 | 35, 38]    
[21 , 28,  ,  ,  ] （第二次 28 与 35 比较，左边子数组胜出， leftIdx = 1 ， i = 1 ）    
第三趟： [21, 28, 39 | 35 , 38]
 [21 , 28 , 35,  ,  ] （第三次 39 与 35 比较，右边子数组胜出， rightIdx = 0 ， i = 2 ）    
第四趟： [21, 28, 39 | 35, 38 ]
 [21 , 28 , 35 , 38,  ] （第四次 39 与 38 比较，右边子数组胜出， rightIdx = 1 ， i = 3 ）    
第五趟： [21, 28, 39 | 35, 38]    
 [21 , 28 , 35 , 38 , 39] （第五次时右边子数组已复制完，无需比较 leftIdx = 2 ， i = 4 ）
</code></pre><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>基本思想：快速排序也是用归并方法实现的一个“分而治之”的排序算法，它的魅力之处在于它能在每次partition（排序算法的核心所在）都能为一个数组元素确定其排序最终正确位置（一次就定位准，下次循环就不考虑这个元素了）。</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>基本思想：初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个 堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。</p>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>基本思想：在有序数组中查找某一特定元素的搜索算法。搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜 素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组 为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。</p>
<h3 id="插补查找"><a href="#插补查找" class="headerlink" title="插补查找"></a>插补查找</h3><p>插补查找是一种类似折半查找的查找方法，插补查找是以比例的概念，求出待查找数据的可能位置，然后进行比较，如果该值比待查找的小，表示待查找的值可能出现在该值之前的范围，就这样一直缩小范围来确定最终的目标</p>
<h3 id="二叉树查找"><a href="#二叉树查找" class="headerlink" title="二叉树查找"></a>二叉树查找</h3><p>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>排序算法参考：<a href="http://easense2009.iteye.com/blog/1568614" target="_blank" rel="external">http://easense2009.iteye.com/blog/1568614</a></p>
<p>查找算法参考：<a href="http://www.iteye.com/news/31161" target="_blank" rel="external">http://www.iteye.com/news/31161</a><br><a href="http://www.open-open.com/solution/view/1410494404789" target="_blank" rel="external">http://www.open-open.com/solution/view/1410494404789</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/04/(3.1).java-集合/" itemprop="url">
                  java-集合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-03-04T17:29:21+08:00" content="2016-03-04">
              2016-03-04
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/集合/" itemprop="url" rel="index">
                    <span itemprop="name">集合</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>Object是所有类的父类，任何类都默认继承Object。</p>
<p>Object类的成员方法：</p>
<ul>
<li><p>clone</p>
<p>  保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常</p>
</li>
<li><p>equals</p>
<p>  在Object中与==是一样的，子类一般需要重写该方法</p>
</li>
<li><p>hashCode</p>
<p>  该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p>
</li>
<li><p>getClass</p>
<p>  final方法，获得运行时类型</p>
</li>
<li><p>wait</p>
<p>  使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>  调用该方法后当前线程进入睡眠状态，直到以下事件发生：</p>
<ol>
<li>其他线程调用了该对象的notify方法</li>
<li>其他线程调用了该对象的notifyAll方法</li>
<li>其他线程调用了interrupt中断该线程</li>
<li>时间间隔到了<br>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常</li>
</ol>
</li>
<li><p>notify</p>
<p>  唤醒在该对象上等待的某个线程</p>
</li>
<li><p>notifyAll</p>
<p>  唤醒在该对象上等待的所有线程</p>
</li>
<li><p>toString</p>
<p>  转换成字符串，一般子类都有重写，否则打印句柄</p>
</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p> Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如<strong>数组、链表、栈、队列、集合、哈希表</strong>等。学习Java集合框架下大致可以分为如下五个部分：List列表、Set集合、Map映射、迭代器（Iterator、Enumeration）、工具类（Arrays、Collections）。</p>
<p>对比：</p>
<p><img src="http://i0.itc.cn/20160907/aac_a1a244d9_64a7_f231_1517_4147e259b281_1.png" alt=""></p>
<h3 id="各接口和类关系"><a href="#各接口和类关系" class="headerlink" title="各接口和类关系"></a>各接口和类关系</h3><p><img src="http://img.blog.csdn.net/20140628144205625" alt=""></p>
<p>集合类主要分为两大类：Collection和Map。</p>
<h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p>是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为两大部分：List和Set。</p>
<ul>
<li>List</li>
</ul>
<p>List接口通常表示一个列表（数组、队列、链表、栈等），其中的元素可以重复，常用实现类为ArrayList和LinkedList，另外还有不常用的Vector。另外，LinkedList还是实现了Queue接口，因此也可以作为队列使用。</p>
<ul>
<li>Set</li>
</ul>
<p>Set接口通常表示一个集合，其中的元素不允许重复（通过hashcode和equals函数保证），常用实现类有HashSet和TreeSet，HashSet是通过Map中的HashMap实现的，而TreeSet是通过Map中的TreeMap实现的。另外，TreeSet还实现了SortedSet接口，因此是有序的集合（集合中的元素要实现Comparable接口，并覆写Compartor函数才行）。</p>
<h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现.</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><blockquote>
<p>特点</p>
</blockquote>
<ul>
<li>ArrayList是基于数组实现的，是一个动态数组，其容量能自动增长，类似于C语言中的动态申请内存，动态增长内存。</li>
<li>ArrayList不是线程安全的，只能用在单线程环境下</li>
<li>ArrayList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问.</li>
</ul>
<blockquote>
<p>源码</p>
<p>总结</p>
</blockquote>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><blockquote>
<p>简介</p>
</blockquote>
<ul>
<li>LinkedList是基于双向循环链表（从源码中可以很容易看出）实现的，除了可以当做链表来操作外，它还可以当做栈、队列和双端队列来使用。</li>
<li>LinkedList同样是非线程安全的，只在单线程下适合使用。</li>
<li>LinkedList实现了Serializable接口，因此它支持序列化，能够通过序列化传输，实现了Cloneable接口，能被克隆。</li>
</ul>
<blockquote>
<p>源码</p>
<p>总结</p>
</blockquote>
<h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><blockquote>
<p>简介</p>
</blockquote>
<ul>
<li>HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。</li>
<li>HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。</li>
<li>HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。</li>
</ul>
<blockquote>
<p>数据结构</p>
</blockquote>
<p>基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。<br>此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
<p>哈希表结构:(例如简单的哈希算法 ： index%哈希因子=位置)<br><img src="http://i1.itc.cn/20160715/aac_d56b5b47_f170_3fe3_69b0_2e6d4023d3f2_1.jpg" alt=""></p>
<p>hashMap存储结构：<br><img src="http://i3.itc.cn/20160715/aac_d56b5b47_f170_3fe3_69b0_2e6d4023d3f2_2.jpg" alt=""></p>
<ul>
<li>hashmap代码</li>
</ul>
<p>~~ </p>
<pre><code>//entry 内部类结构 
static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
    final K key;
    V value;
    Entry&lt;K,V&gt; next;  下一个entry的指针
    int hash;

    /**
     * Creates new entry.
     */
    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

/**
 * 计算hashcode
 */
static int indexFor(int h, int length) {
    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;
    return h &amp; (length-1);
}

 /**
 * The table, resized as necessary. Length MUST Always be a power of two.
 */
transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;


// 添加entry 
void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}    
</code></pre><p>~~</p>
<ul>
<li>Map.Entry接口设计</li>
</ul>
<p>Map是java中的接口，Map.Entry是Map的一个内部接口。keySet()方法返回值是Map中key值的集合；entrySet()的返回值也是返回一个Set集合，此集合的类型为Map.Entry。</p>
<blockquote>
<p>API接口 get/put/remove</p>
</blockquote>
<p>~~ java</p>
<pre><code>// get获取value
public V get(Object key) {
    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();
    if (key==null) {
        while (i.hasNext()) {
            Entry&lt;K,V&gt; e = i.next();
            if (e.getKey()==null)
                return e.getValue();
        }
    } else {
        while (i.hasNext()) {
            Entry&lt;K,V&gt; e = i.next();
            if (key.equals(e.getKey()))
                return e.getValue();
        }
    }
    return null;
}
</code></pre><blockquote>
<p>非线程安全及扩容</p>
</blockquote>
<p>可参考：<a href="http://ifeve.com/hashmap-infinite-loop/" target="_blank" rel="external">http://ifeve.com/hashmap-infinite-loop/</a></p>
<p>两个线程并发情况下,扩容时可能会创建出 2 个新数组容器</p>
<p>~~ java</p>
<pre><code>// 扩容操作,从一个数组转移到另一个数组
void transfer(Entry[] newTable) { 
    Entry[] src = table;
    int newCapacity = newTable.length; 
    for (int j = 0; j &lt; src.length; j++) {
        Entry&lt;K,V&gt; e = src[j]; 
        if (e != null) {
            src[j] = null; 
            do {
                Entry&lt;K,V&gt; next = e.next; //假设第一个线程执行到这里 
                int i = indexFor(e.hash, newCapacity);
                e.next = newTable[i];
                newTable[i] = e;
                e = next;
            } while (e != null); // 可能导致死循环
        }
    }
}
</code></pre><blockquote>
<p>总结</p>
</blockquote>
<h3 id="hashTable"><a href="#hashTable" class="headerlink" title="hashTable"></a>hashTable</h3><blockquote>
<p>数据结构</p>
<p>线程安全</p>
</blockquote>
<h3 id="对比hashmap和hashtable"><a href="#对比hashmap和hashtable" class="headerlink" title="对比hashmap和hashtable"></a>对比hashmap和hashtable</h3><ul>
<li>继承不同。</li>
</ul>
<p>public class Hashtable extends Dictionary implements Map</p>
<p>public class HashMap  extends AbstractMap implements Map</p>
<ul>
<li>是否线程安全</li>
</ul>
<p>Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p>
<ul>
<li>是否允许null值</li>
</ul>
<p>Hashtable中，key和value都不允许出现null值。</p>
<p>在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p>
<ul>
<li>两个遍历方式的内部实现上不同。</li>
</ul>
<p>Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p>
<ul>
<li>哈希值</li>
</ul>
<p>哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p>
<ul>
<li>扩容方式</li>
</ul>
<p>Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<h3 id="concurrentHashMap"><a href="#concurrentHashMap" class="headerlink" title="concurrentHashMap"></a>concurrentHashMap</h3><p>在并发编程中 使用hashmap回导致程序死循环，使用hashtable效率会非常低，所以出现了consurrentHashMap.</p>
<ul>
<li>锁分离技术（Lock Stripping） <code>分拆锁</code> <code>分离锁</code></li>
</ul>
<p>分拆锁(lock spliting)就是若原先的程序中多处逻辑都采用同一个锁，但各个逻辑之间又相互独立，就可以拆(Spliting)为使用多个锁，每个锁守护不同的逻辑。<br>分拆锁有时候可以被扩展，分成可大可小加锁块的集合，并且它们归属于相互独立的对象，这样的情况就是分离锁(lock striping)。</p>
<p><img src="http://cdn3.infoqstatic.com/statics_s2_20160712-0252/resource/articles/ConcurrentHashMap/zh/resources/2.jpg" alt=""></p>
<ul>
<li>原子操作</li>
</ul>
<blockquote>
<p>数据结构</p>
</blockquote>
<ul>
<li>concurrentHashMap结构</li>
</ul>
<p><img src="http://i1.itc.cn/20160715/aac_d56b5b47_f170_3fe3_69b0_2e6d4023d3f2_3.jpg" alt=""></p>
<blockquote>
<p>操作</p>
</blockquote>
<ul>
<li>ConcurrentHashMap的初始化</li>
</ul>
<p>ConcurrentHashMap初始化方法是通过initialCapacity，loadFactor, concurrencyLevel几个参数来初始化segments数组，段偏移量segmentShift，段掩码segmentMask和每个segment里的HashEntry数组 。</p>
<p>初始化每个Segment。输入参数initialCapacity是ConcurrentHashMap的初始化容量，loadfactor是每个segment的负载因子，在构造方法里需要通过这两个参数来初始化数组中的每个segment。</p>
<pre><code>if (initialCapacity &gt; MAXIMUM_CAPACITY)
    initialCapacity = MAXIMUM_CAPACITY;
int c = initialCapacity / ssize;
if (c * ssize &lt; initialCapacity)
    ++c;
int cap = 1;
while (cap &lt; c)
    cap &lt;&lt;= 1;
for (int i = 0; i &lt; this.segments.length; ++i)
    this.segments[i] = new Segment&lt;K,V&gt;(cap, loadFactor);
</code></pre><p>上面代码中的变量cap就是segment里HashEntry数组的长度，它等于initialCapacity除以ssize的倍数c，如果c大于1，就会取大于等于c的2的N次方值，所以cap不是1，就是2的N次方。segment的容量threshold＝(int)cap*loadFactor，默认情况下initialCapacity等于16，loadfactor等于0.75，通过运算cap等于1，threshold等于零。</p>
<ul>
<li>定位Segment </li>
</ul>
<p>可以看到ConcurrentHashMap会首先使用Wang/Jenkins hash的变种算法对元素的hashCode进行一次再哈希。</p>
<p>private static int hash(int h) {<br>        h += (h &lt;&lt; 15) ^ 0xffffcd7d;<br>        h ^= (h &gt;&gt;&gt; 10);<br>        h += (h &lt;&lt; 3);<br>        h ^= (h &gt;&gt;&gt; 6);<br>        h += (h &lt;&lt; 2) + (h &lt;&lt; 14);<br>        return h ^ (h &gt;&gt;&gt; 16);<br>    }<br>之所以进行再哈希，其目的是为了减少哈希冲突，使元素能够均匀的分布在不同的Segment上，从而提高容器的存取效率。</p>
<ul>
<li>ConcurrentHashMap的get操作</li>
</ul>
<p>Segment的get操作实现非常简单和高效。先经过一次再哈希，然后使用这个哈希值通过哈希运算定位到segment，再通过哈希算法定位到元素，代码如下：</p>
<pre><code>public V get(Object key) {
    int hash = hash(key.hashCode());
    return segmentFor(hash).get(key, hash);
}
</code></pre><p>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空的才会加锁重读，我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHashMap的get操作是如何做到不加锁的呢？原因是它的get方法里将要使用的共享变量都定义成volatile，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。<strong>定义成volatile的变量，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值</strong>，但是只能被单线程写（有一种情况可以被多线程写，就是写入的值不依赖于原值），在get操作里只需要读不需要写共享变量count和value，所以可以不用加锁。之所以不会读到过期的值，是根据Java内存模型的happen before原则，对volatile字段的写入操作先于读操作，即使两个线程同时修改和获取volatile变量，get操作也能拿到最新的值，这是用volatile替换锁的经典应用场景。</p>
<pre><code>transient volatile int count;
volatile V value;
</code></pre><ul>
<li>ConcurrentHashMap的Put操作</li>
</ul>
<p>由于put方法里需要对共享变量进行写入操作，所以为了线程安全，在操作共享变量时必须得加锁。Put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，</p>
<ul>
<li>第一步判断是否需要对Segment里的HashEntry数组进行扩容</li>
<li>第二步定位添加元素的位置然后放在HashEntry数组里</li>
</ul>
<p>如何扩容。扩容的时候首先会创建一个两倍于原容量的数组，然后将原数组里的元素进行再hash后插入到新的数组里。为了高效ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。</p>
<ul>
<li>ConcurrentHashMap的size操作</li>
</ul>
<p>如果我们要统计整个ConcurrentHashMap里元素的大小，就必须统计所有Segment里元素的大小后求和。Segment里的全局变量count是一个volatile变量，那么在多线程场景下，我们是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢？不是的，虽然相加时可以获取每个Segment的count的最新值，但是拿到之后可能累加前使用的count发生了变化，那么统计结果就不准了。所以最安全的做法，是在统计size的时候把所有Segment的put，remove和clean方法全部锁住，但是这种做法显然非常低效。 因为在累加count操作过程中，之前累加过的count发生变化的几率非常小，所以ConcurrentHashMap的做法是先尝试2次通过不锁住Segment的方式来统计各个Segment大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</p>
<p>那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢？使用modCount变量，在put , remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统计size前后比较modCount是否发生变化，从而得知容器的大小是否发生变化。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>java集合源码解析：<a href="http://blog.csdn.net/column/details/collection.html?page=1" target="_blank" rel="external">http://blog.csdn.net/column/details/collection.html?page=1</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/metor.ico"
               alt="Pedestrian" />
          <p class="site-author-name" itemprop="name">Pedestrian</p>
          <p class="site-description motion-element" itemprop="description">study for goal</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">60</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">59</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yanan0628" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://carlosfu.github.io/" target="_blank" title="fudada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  fudada
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://jolinzhangg.github.io/" target="_blank" title="xiaodada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  xiaodada
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pedestrian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
