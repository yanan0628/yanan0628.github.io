<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="study for goal">
<meta property="og:type" content="website">
<meta property="og:title" content="Meteor">
<meta property="og:url" content="/page/4/index.html">
<meta property="og:site_name" content="Meteor">
<meta property="og:description" content="study for goal">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Meteor">
<meta name="twitter:description" content="study for goal">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Meteor </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Meteor</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/03/(8.3).JAVA虚拟机(三)-CMS垃圾回收器/" itemprop="url">
                  CMS Heap Stucture
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-03T16:37:35+08:00" content="2016-08-03">
              2016-08-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="概念认知"><a href="#概念认知" class="headerlink" title="概念认知"></a>概念认知</h3><h4 id="枚举根节点-GC-root"><a href="#枚举根节点-GC-root" class="headerlink" title="枚举根节点 GC root"></a>枚举根节点 GC root</h4><p>可达性分析对执行时间的敏感体现在GC停顿上，这项工作分析必须确保能在”一致性”的快照进行操作，(冻结某个时间点上对象引用关系以及任何对象引用变更)，这也是为什么会产生Stop The Word.</p>
<p>在HotSpot虚拟机实现中，是有办法直接获取哪些地方(OopMap的数据结构)存放着对象的引用。当虚拟机在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么数据类型计算出来，再JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是被引用的。</p>
<h4 id="安全点-safe-point"><a href="#安全点-safe-point" class="headerlink" title="安全点 safe point"></a>安全点 safe point</h4><p>在OopMap的协助下，HotSpot可快速且准确的完成GC roots枚举，但是有一个问题：引用关系变化会比较频繁会造成OopMap内容变化指令非常多，那样会需要大量的额外空间，这样GC空间成本会很高。</p>
<p><em>但实际上HotSpot，只是会”特定的位置”记录这些信息，这些位置简称<strong>安全点-safepoint</strong>，即程序执行时并非在所有地方都能停顿下来开始GC，只有达到安全点时才能暂停。</em></p>
<p>如何在GC发生时让所有线程，都”跑”到最近安全点上停顿下来，两种方案：</p>
<ul>
<li>抢断式中断</li>
</ul>
<p>不需要线程的执行代码主动配合，在gc发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，就让”该线程跑到”安全点上。</p>
<ul>
<li>主动式中断 (hotspot)</li>
</ul>
<p>当GC需要中断线程的时候，不需要对线程操作，仅仅简单的设置一个标志位，各个线程执行时 主动去轮训这个标志，发现中断标志位为真，才让线程挂起。</p>
<h4 id="安全区域-safe-region"><a href="#安全区域-safe-region" class="headerlink" title="安全区域 safe region"></a>安全区域 safe region</h4><p>safepoint似乎已经完美解决如何进入GC的问题，但实际情况不一样。safepoint机制是保证程序执行时，在不太久时间内就会遇到可进入GC的safepoint,但是程序 “不执行”的时候呢?</p>
<ul>
<li>程序没有获取到cpu的时间片</li>
<li>线程处于sleep或bolcked状态<br>这些情况线程是无法响应JVM的中断请求，无法”跑到”安全的地方去中断挂起，这里就需要用到 <em>安全区域safe-region</em>来解决。</li>
</ul>
<p><strong>安全区域safe-region</strong>指的是在一段代码片段中，引用关系不会发生变化。在这个区域的任意地方开始GC都是安全的，可以把它看做是safe-point的扩展。</p>
<p>在线程执行到safe Region的代码时，首先标识自己已经进入了Safe Region,那样，当JVM要发起GC时，就不用管标识自己为safe region状态的线程，当线程离开safe region时，就需要检查系统 是否已经完成 根节点枚举，如果完成就继续执行，否则它就必须等待直到收到可以离开safe region的信号为止。</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p>
<p>虚拟机总共运行100分钟，其中垃圾收集花掉1分钟，那么吞吐量是 99%。</p>
<h4 id="并行-并发收集区别"><a href="#并行-并发收集区别" class="headerlink" title="并行/并发收集区别"></a>并行/并发收集区别</h4><ul>
<li>并行（parallel）：只多条垃圾收集线程并行工作，但此时用户线程任然处于等待状态。</li>
<li>并发(Concurent)：指用户线程与垃圾收集线程同时执行(不一定是并行的，可能需要交替执行)，垃圾收集程序运行另外一个Cpu上。(收集线程数=(cpu数量+3)/4 ,不足4个 对用户程序影响可能变大)</li>
</ul>
<h3 id="Reviewing-Generational-GC-and-CMS"><a href="#Reviewing-Generational-GC-and-CMS" class="headerlink" title="Reviewing Generational GC and CMS"></a>Reviewing Generational GC and CMS</h3><p>The Concurrent Mark Sweep (CMS) collector (also referred to as the concurrent low pause collector) collects the tenured generation. It attempts to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads. Normally the concurrent low pause collector does not copy or compact the live objects. A garbage collection is done without moving the live objects. If fragmentation becomes a problem, allocate a larger heap.  </p>
<p>大致意思：CMS垃圾回收器是回收堆中老年代对象。它与应用线程并行做垃圾回收以减少最小停顿时间，它的最小停顿时间不是因为 复制或整理存活对象，最主要问题是因为碎片化，所以需要分配一个较大的堆。</p>
<p>特点：</p>
<ul>
<li>牺牲吞吐量换取最小停顿时间 </li>
<li>并发标记清除垃圾回收算法</li>
<li>需要一个较大的堆空间</li>
</ul>
<p>问题：</p>
<ul>
<li>产生碎片化</li>
</ul>
<blockquote>
<p>Heap Structure for Cms Collector</p>
</blockquote>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide1.png" alt=""></p>
<h3 id="CMS-Collection-Phase-CMS收集阶段"><a href="#CMS-Collection-Phase-CMS收集阶段" class="headerlink" title="CMS Collection Phase(CMS收集阶段)"></a>CMS Collection Phase(CMS收集阶段)</h3><p>CMS收集器有几个缺点：</p>
<ul>
<li><p>cms收集器占用cpu资源，总吞吐量会降低</p>
<p>  在并发阶段，它虽然不会导致用户线程停顿，但是占用可一部分线程(或者说CPU资源)，从而导致应用程序变慢。</p>
</li>
<li><p>cms收集器无法处理”浮动垃圾”</p>
<p>  由于cms并发清理阶段，用户线程还在运行着，伴随着程序运行自然会产生新的垃圾，这一部分垃圾在标记过程中，无法再这一次GC处理，需要等待下一次GC是再清理掉。这一部分垃圾成为<strong>浮动垃圾</strong>。可以适当调整老年代回收百分比参数：-XX:CMSInitiationgOccupancyFraction ,<strong>还可能会造成Concurrent Mode Failure失败导致另一次FullGC产生。</strong><br>  jdk1.5 老年代触发 百分比68%，JDK1.6 老年代触发百分比 92%</p>
</li>
<li><p>cms收集器会产生空间碎片，可能会造成额外FULL GC触发</p>
<p>  由于CMS是基于”标记-清除”算法实现，意味着收集结束会产生大量空碎片空间，如果碎片过多时，将会给大对象分配带来很大麻烦，此时往往老年代还有很多空间剩余，会造成提前一次进行FULL gc的触发，为解决这个问题，cms提供一个参数 +useCmsCompactAtFullCollection（碎片整理，默认开启），内存整理肯定就增加了停顿时间，虚拟器还提供一个参数-XX:CMSFullGCBeforeCompaction,这个参数 用于设置执行多少次不压缩的Full Gc后，跟着来一次带压缩的(默认值为0，表示每次进入Full GC都要进行碎片整理)</p>
</li>
</ul>
<blockquote>
<p>CMS收集过程</p>
</blockquote>
<p><img src="http://dl2.iteye.com/upload/attachment/0115/7590/5e899581-4025-3895-bc08-d702fc71dff5.png" alt=""></p>
<p>初始标记仅仅是标记一下GC Roots能直接关联到的对象，速度很快，并发标记就是进行<br>GC Roots Trancing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继<br>续运行而导致标记产生变动那一部分对象的标记记录，这个阶段的停顿时间比初始标记稍<br>长一些，但远比并发标记时间短。</p>
<p><img src="http://i2.itc.cn/20160904/aac_6f45a003_baef_f7c1_93fb_a261e84665e3_1.png" alt=""></p>
<h3 id="How-YoungGC-works-with-GC-CMS年轻代回收过程"><a href="#How-YoungGC-works-with-GC-CMS年轻代回收过程" class="headerlink" title="How YoungGC works with GC(CMS年轻代回收过程)"></a>How YoungGC works with GC(CMS年轻代回收过程)</h3><p>使用算法：copying算法(速度快 存活对象少)</p>
<ul>
<li>1.The young generation is colored light green and the old generation in blue. This is what the CMS might look like if your application has been running for a while. Objects are scattered around the old generation area.</li>
</ul>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide2.png" alt=""></p>
<ul>
<li>2.Live objects are copied from the Eden space and survivor space to the other survivor space. Any older objects that have reached their aging threshold are promoted to old generation.</li>
</ul>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide3.png" alt=""></p>
<ul>
<li>3.After a young GC, the Eden space is cleared and one of the survivor spaces is cleared.</li>
</ul>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide4.png" alt=""><br>Newly promoted objects are shown in dark blue on the diagram. The green objects are surviving young generation objects that have not yet been promoted to old generation. </p>
<h3 id="Old-Generation-Collection-With-CMS（CMS老年代垃圾回收）"><a href="#Old-Generation-Collection-With-CMS（CMS老年代垃圾回收）" class="headerlink" title="Old Generation Collection With CMS（CMS老年代垃圾回收）"></a>Old Generation Collection With CMS（CMS老年代垃圾回收）</h3><ul>
<li>1.Two stop the world events take place: initial mark and remark. When the old generation reaches a certain occupancy rate, the CMS is kicked off。</li>
</ul>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide5.png" alt=""><br>(1) Initial mark is a short pause phase where live (reachable) objects are marked. (2) Concurrent marking finds live objects while the application continues to execute. Finally, in the (3) remark phase, objects are found that were missed during (2) concurrent marking in the previous phase.</p>
<ul>
<li>2.Objects that were not marked in the previous phase are deallocated in place. There is no compaction.</li>
</ul>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide6.png" alt=""><br>Note: Unmarked objects == Dead Objects</p>
<ul>
<li>3.After the (4) Sweeping phase, you can see that a lot of memory has been freed up. You will also notice that no compaction has been done.</li>
</ul>
<p><img src="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/images/slide7.png" alt=""><br>Finally, the CMS collector will move through the (5) resetting phase and wait for the next time the GC threshold is reached..</p>
<h3 id="CMS参数解释"><a href="#CMS参数解释" class="headerlink" title="CMS参数解释"></a>CMS参数解释</h3><p>-XX：+UseConcMarkSweepGC</p>
<pre><code>激活CMS收集器。默认HotSpot JVM使用的是并行收集器
</code></pre><p>-XX：UseParNewGC</p>
<pre><code>当使用-XX：+UseConcMarkSweepGC时，-XX：UseParNewGC会自动开启。因此，
如果年轻代的并行GC不想开启，可以通过设置-XX：-UseParNewGC来关掉。
</code></pre><p>-XX：+CMSConcurrentMTEnabled</p>
<pre><code>当该标志被启用时，并发的CMS阶段将以多线程执行
(因此，多个GC线程会与所有的应用程序线程并行工作)。该标志已经默认开启，
如果顺序执行更好，这取决于所使用的硬件，多线程执行可以通过-XX：-CMSConcurremntMTEnabled禁用。
</code></pre><p>-XX：ConcGCThreads</p>
<pre><code>标志-XX：ConcGCThreads=&lt;value&gt;(早期JVM版本也叫-XX:ParallelCMSThreads)定义并发CMS
过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。尽管更多的线
程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试
来判断增加CMS线程数是否真的能够带来性能的提升。如果还标志未设置，JVM会根据并行收集器中
的-XX：ParallelGCThreads参数的值来计算出默认的并行CMS线程数。该公式是ConcGCThreads
 = (ParallelGCThreads + 3)/4。因此，对于CMS收集器， -XX:ParallelGCThreads标志不
仅影响“stop-the-world”垃圾收集阶段，还影响并发阶段。
</code></pre><p>-XX:CMSInitiatingOccupancyFraction</p>
<pre><code>当堆满之后，并行收集器便开始进行垃圾收集，例如，当没有足够的空间来容纳新分配或提升的对
象,JVM会在一开始执行CMS周期前作一些线索查找。该线索由 -
XX:CMSInitiatingOccupancyFraction=&lt;value&gt;来设置，该值代表老年代堆空间的使用率.
</code></pre><p>-XX：+UseCMSInitiatingOccupancyOnly</p>
<pre><code>触发fullGC的空间百分比，jdk5 默认68%  jdk6 默认92%
</code></pre><p>-XX:+CMSClassUnloadingEnabled</p>
<pre><code>相对于并行收集器，CMS收集器默认不会对永久代进行垃圾回收。如果希望对永久代进行垃圾回收，
可用设置标志-XX:+CMSClassUnloadingEnabled。
</code></pre><p>-XX:+UseCMSCompactAtFullCollection</p>
<pre><code>打开对年老代的压缩.可能会影响性能,但是可以消除碎片,由于并发收集器不对内存空间进行压缩,
整理,所以运行一段时间以后会产生&quot;碎片&quot;,使得运行效率降低.此值设置运行多少次GC以后对内存
空间进行压缩,整理.
</code></pre><p>-XX:+ExplicitGCInvokesConcurrent and </p>
<p>-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</p>
<p>-XX:+DisableExplicitGC</p>
<p>该标志将告诉JVM完全忽略系统的GC调用(不管使用的收集器是什么类型)</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>oracle官网cms垃圾回收：<a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html" target="_blank" rel="external">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/02/(8.2).JAVA虚拟机(二)-GC介绍及垃圾回收算法/" itemprop="url">
                  GC介绍及垃圾回收算法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-02T16:37:35+08:00" content="2016-08-02">
              2016-08-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="GC介绍"><a href="#GC介绍" class="headerlink" title="GC介绍"></a>GC介绍</h2><h3 id="什么是GC-Garbage-Collection"><a href="#什么是GC-Garbage-Collection" class="headerlink" title="什么是GC(Garbage Collection)?"></a>什么是GC(Garbage Collection)?</h3><p>垃圾回收器（Garbage Collection，GC）,顾名思义，垃圾回收就是释放垃圾占用的空间， Java中，程序员不需要去关心内存动态分配和垃圾回收的问题，这一切都交给了JVM来处理。<br>我们需要考虑一下JVM处理垃圾回收三个问题：<br>1).哪些内存需要回收？<br>2).GC什么时候开始回收？<br>3).如何回收?</p>
<h3 id="垃圾收集的方式？"><a href="#垃圾收集的方式？" class="headerlink" title="垃圾收集的方式？"></a>垃圾收集的方式？</h3><ul>
<li>引用计数方式</li>
</ul>
<p><img src="http://dl2.iteye.com/upload/attachment/0115/7187/5dcb87dd-84b7-3fd4-990e-4ad03fbb23d3.png" alt=""></p>
<ul>
<li>对象遍历引用方式</li>
</ul>
<p><img src="http://dl2.iteye.com/upload/attachment/0115/7185/d546c4ef-d358-3252-bf83-1cf2a969450d.png" alt=""></p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/02/(8.2).JAVA虚拟机(二)-GC介绍及垃圾回收算法/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/01/(8.1).JAVA虚拟机(一)-java体系结构及hotspot介绍/" itemprop="url">
                  Java体系结构及内存模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-01T16:37:35+08:00" content="2016-08-01">
              2016-08-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="Java概论"><a href="#Java概论" class="headerlink" title="Java概论"></a>Java概论</h2><h3 id="Java体系结构"><a href="#Java体系结构" class="headerlink" title="Java体系结构"></a>Java体系结构</h3><p>java模块划分：</p>
<p><img src="http://i1.itc.cn/20160829/aac_76c29c80_99bc_17d0_839f_c79902930a42_4.png" alt=""></p>
<p>JDK,JRE,JVM,JIT关系:</p>
<p><img src="http://i2.itc.cn/20160829/aac_76c29c80_99bc_17d0_839f_c79902930a42_5.png" alt=""></p>
<h3 id="HotSpot-JVM标准结构"><a href="#HotSpot-JVM标准结构" class="headerlink" title="HotSpot JVM标准结构"></a>HotSpot JVM标准结构</h3><p><img src="http://i3.itc.cn/20160829/aac_76c29c80_99bc_17d0_839f_c79902930a42_1.png" alt=""></p>
<ul>
<li>最上层：javac编译器将编译好的字节码class文件,通过java类装载器的执行机制，把对象或class文件 存放在 jvm划分内存区域</li>
<li>中间层：从左至右 <code>方法区</code>(持久代也叫非堆)、<code>堆</code>(共享,GC回收对象区域)、<code>栈</code>、<code>程序计数器</code>和<code>寄存器</code>、<code>本地栈</code>(私有)</li>
<li>最下层：jvm最核心两块 JIT(just in time)即时编译器 和 GC（Garbage Collection,垃圾回收器）</li>
</ul>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/08/01/(8.1).JAVA虚拟机(一)-java体系结构及hotspot介绍/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/02/(7.4).分布式架构-elasticSearch/" itemprop="url">
                  elasticsearch
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-02T10:52:03+08:00" content="2016-07-02">
              2016-07-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式/搜索引擎/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h2 id="ElasticSearch初识"><a href="#ElasticSearch初识" class="headerlink" title="ElasticSearch初识"></a>ElasticSearch初识</h2><h3 id="介绍及特点"><a href="#介绍及特点" class="headerlink" title="介绍及特点"></a>介绍及特点</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>作为开源分布式搜索和数据处理平台，Elasticsearch不仅仅是一个数据库，同时它还是一个基于Lucene构建的开源、分布式、RESTful信息检索框架，能够实时搜索，并且稳定可靠，EIK架构为编程人员提供了一个分布式的可扩展的信息检索和基于Lucene的全文搜索，基于Logstash的日志处理机制、基于Kibana的挖掘结果可视化的的机制。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>分布式实时文件存储</li>
<li>实时分析的分布式搜索引擎</li>
<li>可以扩展到上百台服务器</li>
</ul>
<h4 id="elasticSearch整体架构："><a href="#elasticSearch整体架构：" class="headerlink" title="elasticSearch整体架构："></a>elasticSearch整体架构：</h4><p><img src="http://i1.itc.cn/20160825/aac_540444d4_baf0_549f_ca6b_c9e63308ca75_1.png" alt=""></p>
<!-- more -->
<h4 id="与Lucene的区别？"><a href="#与Lucene的区别？" class="headerlink" title="与Lucene的区别？"></a>与Lucene的区别？</h4><p>Elasticsearch执行搜索的速度更快，可以简单的通过HTTP方式，使用JSON来操作数据，并支持对分布式集群的搜索。<br>Elasticsearch对分布式支持，其索引功能分拆为多个分片，每个分片可有0个或多个副本，集群中的每个数据节点都可承载一个或多个分片，并且能协调和处理各种操作；负载再平衡（Rebalancing）和路由（Routing）在大多数情况下都是自动完成的。</p>
<h3 id="安装及目录"><a href="#安装及目录" class="headerlink" title="安装及目录"></a>安装及目录</h3><blockquote>
<p>安装</p>
</blockquote>
<p><a href="http://www.shaheng.me/blog/2015/06/elasticsearch--.html" target="_blank" rel="external">http://www.shaheng.me/blog/2015/06/elasticsearch--.html</a></p>
<p><a href="http://10.16.51.33:9200/_plugin/head/" target="_blank" rel="external">http://10.16.51.33:9200/_plugin/head/</a></p>
<p>测试路由：<a href="http://10.16.51.33:9200/_plugin/paramedic/index.html" target="_blank" rel="external">http://10.16.51.33:9200/_plugin/paramedic/index.html</a></p>
<blockquote>
<p>源码编译</p>
</blockquote>
<p>jdk1.8/gradle2.8以上版本</p>
<p>gradle compileJava</p>
<blockquote>
<p>data索引目录</p>
</blockquote>
<p><strong>data目录结构：</strong><br><img src="http://i3.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_5.png" alt=""></p>
<pre><code>node.lock    是用来确保一个data目录只被唯一的elasticsearch应用使用。
global_0.st    是个二进制文件，该文件包含了集群的元数据。比如一些persistent持久的修改。
            0表示元数据的版本。
</code></pre><p><strong>index索引目录:</strong><br><img src="http://i0.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_4.png" alt=""></p>
<pre><code>0            表示索引indice2在该节点上的1号分片。
state-23    表示的是索引_state的状态信息，23表示的是版本。这个文件中包含了索引的元数据，                如索引的创建时间，索引的设置和mapping。
state-31    表示的是分片的状态，比如该分片是否是主分片。
</code></pre><h3 id="lucene相关概念"><a href="#lucene相关概念" class="headerlink" title="lucene相关概念"></a>lucene相关概念</h3><blockquote>
<p>index和search过程的流程图</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160825/aac_6527b376_6486_182e_c9e9_096d8163b67d_1.png" alt=""></p>
<pre><code>Lucene的analysis模块主要负责词法分析及语言处理而形成Term。
Lucene的index模块主要负责索引的创建，里面有IndexWriter。
Lucene的store模块主要负责索引的读写。
Lucene的QueryParser主要负责语法分析。
Lucene的search模块主要负责对索引的搜索。
Lucene的similarity模块主要负责对相关性打分的实现。
</code></pre><blockquote>
<p>相关概念</p>
</blockquote>
<p>lucene 存储的层次结构</p>
<p><img src="http://i2.itc.cn/20160825/aac_c36de6c2_193e_b59a_8332_6c7776d106c4_1.png" alt=""></p>
<ul>
<li><p>索引(Index)：在Lucene中一个索引是放在一个文件夹中的。</p>
</li>
<li><p>段(Segment)：一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。具有相同前缀文件的属同一个段，图中共两个段 “_0” 和 “_1”。<br>segments.gen和segments_5是段的元数据文件，也即它们保存了段的属性信息。</p>
<p>  可参考es： <a href="http://*.*.*.*:9200/kis-index-v1/_segments">http://*.*.*.*:9200/kis-index-v1/_segments</a> 段信息</p>
</li>
<li><p>文档(Document)：<br>文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。<br>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。</p>
</li>
<li><p>域(Field)：一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。<br>不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。</p>
</li>
<li><p>词(Term)：<br>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</p>
</li>
</ul>
<p>Lucene的索引结构中，即保存了正向信息，也保存了反向信息。</p>
<blockquote>
<p>elasticsearch保存的部分索引文件格式：</p>
</blockquote>
<p><img src="http://i0.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_3.png" alt="索引文件部分格式"></p>
<p><strong>所谓正向信息：</strong></p>
<p>按层次保存了从索引，一直到词的包含关系：<br>索引(Index) –&gt; 段(segment) (segments.gen, segments_N) -&gt; 文档(Document)–&gt; 域(Field)(fnm, fdx, fdt) –&gt; 词(Term) (tvx, tvd, tvf)<br>也即此索引包含了那些段，每个段包含了那些文档，每个文档包含了那些域，每个域包含了那些词。</p>
<p>如上图，包含正向信息的文件有：</p>
<pre><code>segments_N  保存了此索引包含多少个段，每个段包含多少篇文档。
.fnm后缀文件 保存了此段包含了多少个域，每个域的名称及索引方式。
.fdx .fdt后缀文件保存了此段包含的所有文档，每篇文档包含了多少域，每个域保存了那些信息。
.tvx，.tvd，.tvf后缀文件 保存了此段包含多少文档，每篇文档包含了多少域，每个域包含了多少词，每个词的字符串，位置等信息。
</code></pre><p><strong>所谓反向信息：</strong></p>
<p>保存了词典到倒排表的映射：词(Term) –&gt; 文档(Document)</p>
<p>如上图，包含反向信息的文件有：</p>
<pre><code>XXX.tis，XXX.tii保存了词典(Term Dictionary)，也即此段包含的所有的词按字典顺序的排序。
XXX.frq保存了倒排表，也即包含每个词的文档ID列表。
XXX.prx保存了倒排表中每个词在包含此词的文档中的位置。
</code></pre><h3 id="elasticsearch-相关概念"><a href="#elasticsearch-相关概念" class="headerlink" title="elasticsearch 相关概念"></a>elasticsearch 相关概念</h3><p>1).<strong>Cluster和Node</strong>——Elasticsearch中的Cluster是对外提供搜索服务的集群，组成这个集群的各个节点叫Node.集群Cluster是一组有着相同cluster.name的节点，他们协同工作，互相分享数据，提供了故障转移和扩展的功能。Node又分为IndexNode、DataNode等。节点之间是对等关系的(去中心化)，而弱化的Master节点只不过多了维护集群状态的功能。</p>
<p>(2).<strong>Shards</strong>——Elasticsearch将一个完整的索引分成若干个部分，每个部分就是一个Shards，每个Shard实际上就是一个基于Lucene的索引。Shards的数量一般在索引创建前制定，且索引创建后不能更改。</p>
<p>(3).<strong>Replicas</strong>——Replics是索引的冗余备份，可用于防止数据丢失或用来做负载均衡。一般地，Elasticsearch会自动对索引请求进行负载均衡。</p>
<p>(4).<strong>Recover</strong>——在有节点加入或退出集群Cluster或故障节点重新启动时，Elasticsearch会根据机器的负载情况，对索引分片Shards进行重新分配。</p>
<p>(5).<strong>River</strong>——River是一个运行在Elasticsearch集群内部的插件，主要用来从外部获取以后数据，然后在Elasticsearch里创建索引。常见的有MongoDB、JDBC river Plugin等。</p>
<p>(6).<strong>Gateway</strong>——是Elasticsearch索引数据快照的存储方式，当Elasticsearch集群关闭再重新启动时，就会从Gateway中读取索引数据快照。Elasticsearch支持多种类型的Gateway,本地文件系统、分布式文件系统、Hadoop的HDFS</p>
<p>(7).<strong>Discover.zen</strong>——Discover.zen代表Elasticsearch的自动发现节点机制。Zen用来实现节点自动发现和Master节点选举，Master节点负责节点的加入和退出以及分片shard的重新分配。</p>
<p>(8).<strong>Transport</strong>——Transport代表Elasticsearch内部节点或集群与客户端的交互方式，默认内部是使用TCP协议进行交互的，同时支持HTTP协议(JSON格式)、Thrift、Servlet等传输协议。</p>
<p>(9)<strong>Index、Type、Document、Field</strong>——Index是数据存储的地方，可以快速高效的堆索引中的数据进行全文索引，类似于RDBMS数据库中的Database;在Index下一般会有多个存储数据的Type,Type类似于Database的table,用来存放具体数据；Document类似于关系数据库的一行数据，在一个Type里的每一个Document都有一个唯一的ID作为区分。</p>
<p>(10)<strong>Mapping</strong>——Mapping定义索引下的Type的字段处理规则，如索引如何建立、索引数据类型、是否保存原始索引JSON文档，是否需要进行分词处理、如何进行分词处理等。一般地，一个索引文件下能存储不同映像(Mapping)的类型文件(Types).</p>
<p>RESTful接口URL的格式：</p>
<pre><code>curl -X&lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos;

VERB HTTP方法：GET(获取), POST(更新), PUT(创建), HEAD, DELETE(删除)
PROTOCOL： http或者https协议（只有在Elasticsearch前面有https代理的时候可用）
HOST： Elasticsearch集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫localhost
PORT： Elasticsearch HTTP服务所在的端口，默认为9200
QUERY_STRING： 一些可选的查询请求参数，例如?pretty参数将使请求返回更加美观易读的JSON数据
BODY： 一个JSON格式的请求主体（如果请求需要的话）
</code></pre><h2 id="ElasticSearch存储结构"><a href="#ElasticSearch存储结构" class="headerlink" title="ElasticSearch存储结构"></a>ElasticSearch存储结构</h2><h3 id="lucene文件存储格式"><a href="#lucene文件存储格式" class="headerlink" title="lucene文件存储格式"></a>lucene文件存储格式</h3><p><img src="http://i2.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_2.png" alt=""><br><img src="http://i1.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_1.png" alt=""></p>
<p><strong>fdx和fdt的结构:</strong></p>
<p>对于每一个域，fieldnum是域号，接着是一个8位的byte，最低一位表示此域是否分词(tokenized)，倒数第二位表示此域是保存字符串数据还是二进制数据，倒数第三位表示此域是否被压缩，再接下来就是存储域的值。</p>
<p>类似 B+树的数据结构：<br><img src="http://i0.itc.cn/20160822/aac_e565d05b_1515_9665_2783_3397228cde23_3.png" alt=""></p>
<p>文件存储大小：<br><img src="http://i2.itc.cn/20160822/aac_5d8cc8be_6498_ec9e_1234_807d0f00ce71_1.png" alt=""></p>
<h3 id="ElasticSearch存储模块"><a href="#ElasticSearch存储模块" class="headerlink" title="ElasticSearch存储模块"></a>ElasticSearch存储模块</h3><ul>
<li><p>simple fs(简单文件系统存储)：对应Lucene中的SimpleFsDirectory。 这种实现的并发性能较差，<strong>多线程会出现瓶颈</strong>。当索引需要持久化最好使用niofs。【windows 32位系统默认使用存储类型】</p>
</li>
<li><p>nio fs(新I/O文件系统存储)：对应Lucene中的NIOFSDirectory。这种方式可以<strong>多个线程在不降低性能的前提下并发地读同一个文件</strong>。【除开simple fs和mmmapfs以外  默认使用存储类型】</p>
</li>
<li><p>mmapfs：它使用mmap系统命令来读取和随机写入文件，并从进程的虚拟地址空间的可用部分中分出与被映射文件大小相同的空间没用于装载被映射文件。它<strong>没有任何锁机制，适合多线程访问，当时有mmap来读取索引时 他就像已经缓存过(映射到虚拟地址空间)，当从lucene索引读取某文件时，不需要把文件载入操作系统缓存中，因此获得了更快的访问速度。这基本上允许lucene和elasticsearch去直接访问I/O缓存，从而获得更快的索引文件访问速度。 一般来说，如果运行的是64位操作系统，你应该选择mmapfs。如果没有运行64位操作系统，为UNIX系统选择niofs，为Windows系统选择simplefs。</strong>【Solaris和windows 64位系统使用存储类型】</p>
</li>
<li><p>memory：对应Lucene中的RamIndexStore，它允许我们把全部索引存放在内存中，因此文件没有存储在硬盘上。这意味着 索引数据是非持久化的，只要集群重启 数据就会被丢失。</p>
</li>
</ul>
<blockquote>
<p>配置</p>
</blockquote>
<pre><code>设置存储类型 index.store.type:

线上es配置：
index.translog.flush_threshold_period: 600s
index.refresh_interval: 10s
indices.memory.index_buffer_size: 30%
indices.memory.min_index_buffer_size: 500m
index.translog.flush_threshold: 50000
index.store.type: mmapfs
index.merge.policy.use_compound_file: false
index.cache.field.type: soft
</code></pre><h3 id="store-level-throttling"><a href="#store-level-throttling" class="headerlink" title="store level throttling"></a>store level throttling</h3><p>Elasticsearch中的segments merge采用异步的方式，但系统低IO的情况下还是会影响索引和查询操作。想要解决这种问题，Elasticsearch提供两种方式（索引级别和节点 级别）的配置。</p>
<pre><code>节点级别配置：
    indices.store.throttle.type：merge
    indices.store.throttle.max_bytes_per_sec：5mb //默认20mb 如上设置之后，该节点上的segments merge不会超过5mb/s
索引级别设置：
    index.store.throttle.type：node
    index.store.throttle.max_bytes_per_sec：10mb
</code></pre><h3 id="段合并策略"><a href="#段合并策略" class="headerlink" title="段合并策略"></a>段合并策略</h3><p>段合并直接影响到系统的性能，需要进行大量的IO操作。段合并策略如下：</p>
<ul>
<li>tiered(默认)</li>
</ul>
<p>ElasticSearch默认合并策略，它能合并大小相似的索引段，并考虑每层允许的索引段的最大个数。</p>
<ul>
<li>log_byte_size</li>
</ul>
<p>按字节数 进行合并</p>
<ul>
<li>log_doc</li>
</ul>
<p>按段里存储doc进行合并</p>
<ul>
<li><p>参数配置</p>
<pre><code>index.merge.policy.type:tiered
</code></pre></li>
</ul>
<blockquote>
<p>segment结构</p>
</blockquote>
<p><img src="http://i2.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_5.png" alt=""><br><img src="http://i0.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_1.png" alt=""><br><img src="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_6.png" alt=""><br><img src="http://i3.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_7.png" alt=""><br><img src="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_8.png" alt=""></p>
<blockquote>
<p>合并过程</p>
</blockquote>
<ul>
<li>提交过程</li>
</ul>
<p><img src="http://i3.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_4.png" alt=""></p>
<ul>
<li>数据落地的步骤</li>
</ul>
<p><img src="http://i0.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_3.png" alt=""></p>
<ul>
<li>segment合并的过程:</li>
</ul>
<p><img src="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_2.png" alt=""></p>
<h3 id="准实时、更新、提交及事务日志"><a href="#准实时、更新、提交及事务日志" class="headerlink" title="准实时、更新、提交及事务日志"></a>准实时、更新、提交及事务日志</h3><p>一个好的搜索引擎需要保证在新索引建立后 数据如何能够立即检索到，</p>
<blockquote>
<p>准实时-版本_version</p>
</blockquote>
<pre><code>每次新建索引 会产生一个新的文档，_version+1，标记旧文档为删除并添加了一个完整的新文
档,旧版本文档不会立即消失，但你也不能去访问它。Elasticsearch会在你继续索引更多数据时
清理被删除的文档。如果新的未建成功，访问仍然是旧的文档内容。
</code></pre><p><img src="http://i3.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_1.png" alt=""> </p>
<blockquote>
<p>索引更新/提交涉及段的合并</p>
</blockquote>
<p>事实上Elasticsearch遵循与之前所说完全相同的过程，这个过程如下：</p>
<ul>
<li>从旧文档中检索JSON</li>
<li>修改它</li>
<li>删除旧文档</li>
<li>索引新文档</li>
</ul>
<p>唯一的不同是update API完成这一过程只需要一个客户端请求既可，不再需要get和index请求了.    </p>
<pre><code>_refresh索引刷新:

    设置参数  &quot;refresh_interval&quot;:&quot;10s/m/h(时间单位)&quot;
    curl -XGET &apos;http://10.16.51.33:9200/data-test/_refresh&apos;
</code></pre><blockquote>
<p>事务日志刷新</p>
</blockquote>
<pre><code>_flush日志刷新：

    设置参数 
    curl -XGET &apos;http://10.16.51.33:9200/data-test/_flush&apos;
    {&quot;_shards&quot;:{&quot;total&quot;:10,&quot;successful&quot;:10,&quot;failed&quot;:0}}
</code></pre><p>查看数据分片情况：<br><img src="http://i1.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_2.png" alt=""><br>执行flush之后<br><img src="http://i1.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_3.png" alt=""></p>
<h2 id="ElasticSearch分布式集群"><a href="#ElasticSearch分布式集群" class="headerlink" title="ElasticSearch分布式集群"></a>ElasticSearch分布式集群</h2><p>es官方文档讲解cluster：<br><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/distributed-cluster.html" target="_blank" rel="external">https://www.elastic.co/guide/en/elasticsearch/guide/current/distributed-cluster.html</a></p>
<p>集群健康：<a href="http://10.16.51.33:9200/_cluster/health" target="_blank" rel="external">http://10.16.51.33:9200/_cluster/health</a></p>
<h3 id="通信机制-发现模块"><a href="#通信机制-发现模块" class="headerlink" title="通信机制-发现模块"></a>通信机制-发现模块</h3><p>该模块主要负责集群中节点的自动发现和Master节点的选举。节点之间使用p2p的方式进行直接通信，不存在单点故障的问题。Elasticsearch中，Master节点维护集群的全局状态，比如节点加入和离开时进行shard的重新分配。通过发现机制(discovery mechanism)极大简化了 集群工作，只需要定义了相同的cluster.name的节点会自动组成集群，需要在同一个网段。</p>
<ul>
<li><p>zen discovery elasticSearch默认实现 多播/单播</p>
<p>  <strong>Master选举</strong>：设置最小主节点候选节点数应设置 集群节点数一半+1，通过参数 discovery.zen.minimum_master_nodes配置当前集群中最少的主节点数。</p>
<p>  <strong>Zen错误发现</strong>：一般存在两个故障检测过程。</p>
<pre><code>第一个是主节点周期性的ping其他节点。
第二就是其他节点周期的ping主节点。
</code></pre><p>  ping_interval：1s节点被ping的频率<br>  ping_timeout：30s等待ping返回的时间<br>  ping_timeout：3重试次数，超过该次，就认为该节点不可用  </p>
<p>  参数配置</p>
<p>  多播：<br>  discovery.zen.ping.multicast.group: 代表发送多播消息地址，默认 224.2.2.4<br>  discovery.zen.ping.multicast.port： 通讯端口，默认值：54328<br>  discovery.zen.ping.multicast.ttl:   定义多播消息的生存期，默认是3<br>  discovery.zen.ping.multicast.address:通讯接口，可赋值地址或接口，默认值：所有接口<br>  discovery.zen.ping.multicast.enabled: 多播自动发现禁用开关 默认值：true</p>
<p>  单播：<br>  discovery.zen.ping.unicast.hosts:host1：port1，host2,：port2  </p>
</li>
<li><p>Azure discovery 插件方式，多播</p>
</li>
<li>EC2 discovery 插件方式，多播</li>
<li>Google Compute Engine (GCE)discovery 插件方式多播</li>
</ul>
<h3 id="故障转移-failover"><a href="#故障转移-failover" class="headerlink" title="故障转移 failover"></a>故障转移 failover</h3><p>数据迁移规则？ 主节点 竞选规则    裁决者</p>
<h3 id="水平-垂直扩容-scale-Horizontally"><a href="#水平-垂直扩容-scale-Horizontally" class="headerlink" title="水平/垂直扩容 scale Horizontally"></a>水平/垂直扩容 scale Horizontally</h3><h3 id="ElasticSearch工作流程"><a href="#ElasticSearch工作流程" class="headerlink" title="ElasticSearch工作流程"></a>ElasticSearch工作流程</h3><blockquote>
<p>创建、索引和删除文档</p>
</blockquote>
<p><img src="http://i1.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_5.png" alt=""></p>
<pre><code>该过程分为以下3步：
1.客户端发送一个创建、检索或删除文档的请求到节点1。
2.节点使用文档的_id（默认情况下，即不指定路由）判断该文档属于分片0。转发请求到主分片0所在的节点3上。
3.节点3在主分片上执行请求。如果成功，则并行的发送请求到0分片的副本分片所在的节点1和节点2上。当所有的副本分片执行成功后，节点3向请求节点报告操作成功，最后请求节点向客户端报告成功。

可以通过修改可选请求参数去修改上述过程。
replication：（默认sync）
    sync：主分片会等待从分片执行成功，然后返回给客户端。
    async：当主分片执行成功则返回给客户端。
    With async replication, it is possible to overload Elasticsearch by sending too many requests without waiting for their completion.

consistency和timeout：
quorum（法定人数）=int( (primary + number_of_replicas) / 2 ) + 1 
只有当活跃的节点数&gt;=quorum时，对索引的创建，索引和删除才会成功。否则等待timeout时长，默认为1分钟，如果期间节点恢复运行，则可以执行索引的创建，索引和删除。否则失败。但是对索引的查询没有影响。
但是当number_of_replicas=1的时候，则无上述限制，即使只有一个节点的时候，也可以进行索引的创建，索引和删除操作。
</code></pre><blockquote>
<p>检索文档</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_3.png" alt=""></p>
<pre><code>该过程分为以下3个部分：
1.客户端发送请求到节点1
2.节点使用_id判断文档属于分片0，分片0存在于这3个节点上。在这个例子中该请求会转发到节点2上。
3.节点2返回文档到节点1，然后节点1再将文档返回客户端。
注：在第二步中之所以要将请求转发到节点2，是为了负载均衡，当节点收到检索命令的时候，elasticsearch会轮询文档所在的分片。
</code></pre><blockquote>
<p>更新文档</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_2.png" alt=""></p>
<pre><code>该过程分为以下4个部分：
1.客户端发送请求到节点1。
2.转发请求到文档所在的主节点3上。
3.节点3从主分片中检索到文档，然后改变文档_source的json数据，尝试重新索引到主分片，如果在这个过程中该文档已经被其他的进程修改了，那么会重复步骤3，如果经过retry_on_conflict 次尝试还是失败，则放弃更新。
4.如果节点3成功的更新了文档，它会将新的文档并行的发送到副本分片所在的节点1和2上。当所有的副本分片都成功的创建了文档时，节点3会通知请求节点更新成功，请求节点再通知客户端更新成功。
注：当主分片转发变更到它的副本分片的时候，它不会发送更新请求，而是发送新版本的文档。
</code></pre><blockquote>
<p>mget操作</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_2.png" alt=""></p>
<pre><code>该过程分为以下两步：
1.客户端发送mget请求到节点1。
2.节点1为每个分片建立一个multi-get请求，并行的发送这些请求到分片所在的主节点或从节点上。当所有分片的响应被返回到节点1时，节点1会建立响应并发送回客户端。
</code></pre><blockquote>
<p>bulk操作</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_1.png" alt=""></p>
<pre><code>该过程步骤如下：
1.客户端发送bulk请求到节点1。
2.节点1为每个主分片建立一个bulk请求，并行的发送这些请求到主分片所在的节点上。
3.主节点顺序的执行每个action，当每一个action成功后，主分片会并行的发送新的文档到副本分片上，然后主分片继续下一个action，当所有副本分片对于所有action的命令都成功时，会向请求节点报告成功，然后请求节点会整理这些响应，并返回到客户端。
注：这个bulk请求需要被读入到内存中，所以越大的请求意味着能被其他请求使用的内存越小。一般来说，bulk请求包含1000-5000个文档，如果文档越大则bulk包含的文档越少。一个好的bulk的size应该在5-15MB左右。
</code></pre><blockquote>
<p>msearch操作/sort排序</p>
</blockquote>
<h3 id="路由模块"><a href="#路由模块" class="headerlink" title="路由模块"></a>路由模块</h3><p>索引别名相当于快捷方式或软链接，可以指向一个或多个索引，甚至可以指向带路由的分片。</p>
<p>指定路由 ：</p>
<p>查询路由：</p>
<p>curl -XGET ‘<a href="http://10.16.51.33:9200/kis-index-v1/kisstar/_search?query=starName:ladygaga&amp;routing=2&amp;explain&amp;pretty" target="_blank" rel="external">http://10.16.51.33:9200/kis-index-v1/kisstar/_search?query=starName:ladygaga&amp;routing=2&amp;explain&amp;pretty</a>‘</p>
<ul>
<li><p>应用实例</p>
<p>  1.将某一聚类数据 特意放在某一分片，提高检索效率</p>
<pre><code>1.1 将用户的数据集放到一个分片
1.2 将专辑下的视频放到一个分片
</code></pre></li>
</ul>
<h3 id="索引别名模块"><a href="#索引别名模块" class="headerlink" title="索引别名模块"></a>索引别名模块</h3><p>Elasticsearch的API支持给索引起别名，有了别名之后可以像使用索引一样使用它。但不只是这些，一个别名可以映射多个索引，所以在需要经常指定多个索引查询的情况下，大可将所查询的索引起一个别名来查。别名也可以将索引查询的过滤条件包含在内，使用别名查询时可以查询索引的一个子集。</p>
<ul>
<li><p>创建一个别名：</p>
<p>  curl -XPOST ‘<a href="http://localhost:9200/_aliases&#39;-d" target="_blank" rel="external">http://localhost:9200/_aliases&#39;-d</a> ‘<br>  {  </p>
<pre><code>&quot;actions&quot; : [  
    { &quot;add&quot; : { &quot;index&quot; : &quot;test1&quot;,&quot;alias&quot; : &quot;alias1&quot; } }  
]  
</code></pre><p>  }’  </p>
</li>
<li><p>删除别名：</p>
<p>  curl -XPOST ‘<a href="http://localhost:9200/_aliases&#39;-d" target="_blank" rel="external">http://localhost:9200/_aliases&#39;-d</a> ‘<br>  {  </p>
<pre><code>&quot;actions&quot; : [  
    { &quot;remove&quot; : { &quot;index&quot; : &quot;test1&quot;,&quot;alias&quot; : &quot;alias1&quot; } }  
]  
</code></pre><p>  }’ </p>
</li>
</ul>
<h2 id="ElasticSearch原理使用"><a href="#ElasticSearch原理使用" class="headerlink" title="ElasticSearch原理使用"></a>ElasticSearch原理使用</h2><h3 id="文档存储及映射规则"><a href="#文档存储及映射规则" class="headerlink" title="文档存储及映射规则"></a>文档存储及映射规则</h3><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>java主类位于org.elasticsearch.bootstrap。主要逻辑是生成了一个InternalNode节点，并且启动了一个keepalive线程。结点的启动代表整个es进程启动了。</p>
<p>Bootstarp启动线程 Node Keepalive</p>
<p>client  TransportClient</p>
<p>~~<br>public enum SearchType {<br>        /**</p>
<pre><code> * Same as {@link #QUERY_THEN_FETCH}, except for an initial scatter phase which goes and computes the distributed
 * term frequencies for more accurate scoring.
 */
DFS_QUERY_THEN_FETCH((byte) 0),
/**
 * The query is executed against all shards, but only enough information is returned (not the document content).
 * The results are then sorted and ranked, and based on it, only the relevant shards are asked for the actual
 * document content. The return number of hits is exactly as specified in size, since they are the only ones that
 * are fetched. This is very handy when the index has a lot of shards (not replicas, shard id groups).
 */
QUERY_THEN_FETCH((byte) 1),
/**
 * Same as {@link #QUERY_AND_FETCH}, except for an initial scatter phase which goes and computes the distributed
 * term frequencies for more accurate scoring.
 */
DFS_QUERY_AND_FETCH((byte) 2),
/**
 * The most naive (and possibly fastest) implementation is to simply execute the query on all relevant shards
 * and return the results. Each shard returns size results. Since each shard already returns size hits, this
 * type actually returns size times number of shards results back to the caller.
 */
QUERY_AND_FETCH((byte) 3),
/**
 * Performs scanning of the results which executes the search without any sorting.
 * It will automatically start scrolling the result set.
 */
SCAN((byte) 4),
/**
 * Only counts the results, will still execute facets and the like.
 */
COUNT((byte) 5);

/**
 * The default search type ({@link #QUERY_THEN_FETCH}.
 */
public static final SearchType DEFAULT = QUERY_THEN_FETCH;
</code></pre><ul>
<li>query and fetch</li>
</ul>
<p>向索引的所有分片（shard）都发出查询请求，各分片返回的时候把元素文档（document）和计算后的排名信息一起返回。这种搜索方式是最快的。因为相比下面的几种搜索方式，这种查询方法只需要去shard查询一次。但是各个shard返回的结果的数量之和可能是用户要求的size的n倍。</p>
<ul>
<li>query then fetch（默认的搜索方式）</li>
</ul>
<p>如果你搜索时，没有指定搜索方式，就是使用的这种搜索方式。这种搜索方式，大概分两个步骤，第一步，先向所有的shard发出请求，各分片只返回排序和排名相关的信息（注意，不包括文档document)，然后按照各分片返回的分数进行重新排序和排名，取前size个文档。然后进行第二步，去相关的shard取document。这种方式返回的document与用户要求的size是相等的。</p>
<ul>
<li>DFS query and fetch</li>
</ul>
<p>这种方式比第一种方式多了一个初始化散发(initial scatter)步骤，有这一步，据说可以更精确控制搜索打分和排名。</p>
<ul>
<li>DFS query then fetch</li>
</ul>
<p>比第2种方式多了一个初始化散发(initial scatter)步骤。</p>
<h3 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h3><blockquote>
<p>文档存储机制</p>
<p>文档CRUD</p>
</blockquote>
<p>PUT/POST/GET/DELETE </p>
<ul>
<li><p>Manually (aka do it yourself) using native byte[] or as a String</p>
<pre><code>String json = &quot;{&quot; +
    &quot;\&quot;user\&quot;:\&quot;kimchy\&quot;,&quot; +
    &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +
    &quot;\&quot;message\&quot;:\&quot;trying out Elasticsearch\&quot;&quot; +
&quot;}&quot;;
</code></pre></li>
<li><p>Using a Map that will be automatically converted to its JSON equivalent</p>
<pre><code>Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();
json.put(&quot;user&quot;,&quot;kimchy&quot;);
json.put(&quot;postDate&quot;,new Date());
json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);
</code></pre></li>
<li><p>Using a third party library to serialize your beans such as Jackson</p>
<pre><code>// instance a json mapper
ObjectMapper mapper = new ObjectMapper(); // create once, reuse

// generate json
byte[] json = mapper.writeValueAsBytes(yourbeaninstance);
</code></pre></li>
<li><p>Using built-in helpers XContentFactory.jsonBuilder()</p>
<pre><code>XContentBuilder builder = jsonBuilder()
.startObject()
    .field(&quot;user&quot;, &quot;kimchy&quot;)
    .field(&quot;postDate&quot;, new Date())
    .field(&quot;message&quot;, &quot;trying out Elasticsearch&quot;)
.endObject();
String json = builder.string();
</code></pre></li>
</ul>
<blockquote>
<p>批量机制 mget bulk msearch </p>
<p>排序规则</p>
</blockquote>
<h2 id="ElasticSearch客户端使用"><a href="#ElasticSearch客户端使用" class="headerlink" title="ElasticSearch客户端使用"></a>ElasticSearch客户端使用</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>maven中央仓库：<a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.elasticsearch%22%20AND%20a%3A%22elasticsearch%22" target="_blank" rel="external">http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.elasticsearch%22%20AND%20a%3A%22elasticsearch%22</a></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;
    &lt;version&gt;${es.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="客户端TransportClient实例化"><a href="#客户端TransportClient实例化" class="headerlink" title="客户端TransportClient实例化"></a>客户端TransportClient实例化</h3><p>Obtaining an elasticsearch Client is simple. The most common way to get a client is by creating a TransportClient that connects to a cluster.</p>
<blockquote>
<p>获取es的client</p>
</blockquote>
<pre><code>// on startup
Client client = TransportClient.builder().build()
        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300))
        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));

// on shutdown
client.close();

// 设置es的别名，否则名称命名为&quot;elasticsearch&quot;
Settings settings = Settings.settingsBuilder()
    .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build();
Client client = TransportClient.builder().settings(settings).build();
//Add transport addresses and do something with the client...

// 设置sniff为true 能自动嗅探 host变更
Settings settings = Settings.settingsBuilder()
    .put(&quot;client.transport.sniff&quot;, true).build();
TransportClient client = TransportClient.builder().settings(settings).build();
</code></pre><blockquote>
<p>工厂类封装es客户端</p>
</blockquote>
<pre><code>//    1.es api接口实现类
public class ElasticSearchCenterImpl implements ElasticSearchCenter {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    private Client client = ElasticSearchClientFactory.createTransportClient();
    //封装es api 接口实现，通过client调用
}

// 2.es api接口定义
public interface ElasticSearchCenter {
    // 定义es api 接口方法
}

// 3.封装TransportClient工厂类 通过配置文件进行初始化
public class ElasticSearchClientFactory {
    private static volatile Client client;

    private ElasticSearchClientFactory() {
    }
    /**
     * create a transport client
     *
     * @return
     */
    public static Client createTransportClient() {
        if (client == null) {
            synchronized (Client.class) {
                if (client != null) {
                    return client;
                }
                ResourceBundle resourceBundle = ResourceBundle.getBundle(&quot;index-engine&quot;);
                String clusterName = resourceBundle.getString(&quot;es.cluster.name&quot;);
                String timeout = resourceBundle.getString(&quot;es.client.transport.ping_timeout&quot;);
                String hosts = resourceBundle.getString(&quot;es.hosts&quot;);
                String sniff = resourceBundle.getString(&quot;es.client.transport.sniff&quot;);

                Settings settings = ImmutableSettings.settingsBuilder()
                        .put(&quot;client.transport.sniff&quot;, sniff)
                        .put(&quot;cluster.name&quot;, clusterName)
                        .put(&quot;client.transport.ping_timeout&quot;, timeout)
                        .build();
                TransportClient innerClient = new TransportClient(settings);
                String[] hostPorts = hosts.split(&quot;,&quot;);
                for (String hostPort : hostPorts) {
                    String[] array = hostPort.split(&quot;:&quot;);
                    innerClient.addTransportAddress(new InetSocketTransportAddress(array[0], Integer.parseInt(array[1])));
                }
                client = innerClient;
            }
        }
        return client;
    }
}
</code></pre><blockquote>
<p>spring启动初始化工厂类</p>
</blockquote>
<pre><code>// 1.添加配置文件
es.hosts=ip:host,ip2:host2,ip3:host3,ip4:host4
es.cluster.name=es-engine-online
es.client.transport.ping_timeout=15000
es.client.transport.sniff=true
// 2.添加spring配置
&lt;!-- elasticsearch  --&gt;
&lt;bean id=&quot;elasticSearchCenter&quot; class=&quot;com.sohu.tv.index.data.engine.es.impl.ElasticSearchCenterImpl&quot; /&gt;
</code></pre><h2 id="ElasticSearch故障处理"><a href="#ElasticSearch故障处理" class="headerlink" title="ElasticSearch故障处理"></a>ElasticSearch故障处理</h2><h3 id="垃圾回收器工作情况"><a href="#垃圾回收器工作情况" class="headerlink" title="垃圾回收器工作情况"></a>垃圾回收器工作情况</h3><h3 id="IO调节"><a href="#IO调节" class="headerlink" title="IO调节"></a>IO调节</h3><h3 id="预热器的使用"><a href="#预热器的使用" class="headerlink" title="预热器的使用"></a>预热器的使用</h3><h3 id="热点线程分析"><a href="#热点线程分析" class="headerlink" title="热点线程分析"></a>热点线程分析</h3><p>热点线程：<a href="http://10.16.51.33:9200/_nodes/hot_threads?type=wait&amp;interval=1s" target="_blank" rel="external">http://10.16.51.33:9200/_nodes/hot_threads?type=wait&amp;interval=1s</a></p>
<h3 id="诊断集群和节点故障API"><a href="#诊断集群和节点故障API" class="headerlink" title="诊断集群和节点故障API"></a>诊断集群和节点故障API</h3><h2 id="Elasticsearch运维使用"><a href="#Elasticsearch运维使用" class="headerlink" title="Elasticsearch运维使用"></a>Elasticsearch运维使用</h2><h3 id="运维命令"><a href="#运维命令" class="headerlink" title="运维命令"></a>运维命令</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><pre><code>ElasticSearch 官方文档 ： https://www.elastic.co/guide/index.html
Elasticsearch 权威指南（中文版）：http://es.xiaoleilu.com/
Elasticsearch资料 : http://blog.csdn.net/july_2/article/details/24453903
ElasticsSearch博客：http://blog.csdn.net/changong28/article/category/2381639/2    

lucene基本概念：http://forfuture1978.iteye.com/blog/546771
lucene文件格式解析：
http://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html
http://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/01/(7.1).分布式架构-dubbo/" itemprop="url">
                  dubbo架构和源码分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-01T10:52:03+08:00" content="2016-07-01">
              2016-07-01
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="dubbo架构原理"><a href="#dubbo架构原理" class="headerlink" title="dubbo架构原理"></a>dubbo架构原理</h2><blockquote>
<h3 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h3></blockquote>
<p><img src="http://i2.itc.cn/20160517/aac_f5d59df3_6197_4d8e_0bd9_908362449c02_2.png" alt="dubbo框架结构"></p>
<ul>
<li><code>config，配置层</code>，对外配置接口，以ServiceConfig, ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类</li>
<li><code>proxy，服务代理层</code>，服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory</li>
<li><code>registry，注册中心层</code>，封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory, Registry, RegistryService</li>
<li><code>cluster，路由层</code>，封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster, Directory, Router, LoadBalance</li>
<li><code>monitor，监控层</code>，RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory, Monitor, MonitorService</li>
<li><code>protocol，远程调用层</code>，封将RPC调用，以Invocation, Result为中心，扩展接口为Protocol, Invoker, Exporter</li>
<li><code>exchange，信息交换层</code>，封装请求响应模式，同步转异步，以Request, Response为中心，扩展接口为Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li><code>transport，网络传输层</code>，抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel, Transporter, Client, Server, Codec</li>
<li><code>serialize，数据序列化层</code>，可复用的一些工具，扩展接口为Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<blockquote>
<h3 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h3></blockquote>
<p><img src="http://i3.itc.cn/20160516/aac_ec527bd3_be4b_a20b_eb92_3020fcd4d4f7_4.jpg" alt="dubbo服务端和客户端调用关系"></p>
<p><strong>节点角色说明：</strong></p>
<ul>
<li>Provider: 暴露服务的服务提供方。</li>
<li>Consumer: 调用远程服务的服务消费方。</li>
<li>Registry: 服务注册与发现的注册中心。</li>
<li>Monitor: 统计服务的调用次调和调用时间的监控中心。</li>
<li>Container: 服务运行容器。</li>
</ul>
<p><strong>调用关系说明：</strong></p>
<ul>
<li>0-服务容器负责启动，加载，运行服务提供者。</li>
<li>1-服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>2-服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>3-注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>4-服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>5-服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ul>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/07/01/(7.1).分布式架构-dubbo/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/14/(6.4).系统故障-单点方案/" itemprop="url">
                  系统单点故障预案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-14T10:38:55+08:00" content="2016-06-14">
              2016-06-14
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/故障预案/" itemprop="url" rel="index">
                    <span itemprop="name">故障预案</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>待补充</p>
<p>##1.单机服务故障</p>
<ul>
<li><p><code>nginx层面</code>：2台nginx+keepalive热备(需要同一网段 )</p>
</li>
<li><p><code>server层面</code>：跨网段或机房</p>
</li>
<li><p><code>接口依赖层面</code>：对所有依赖进行隔离(mysql、redis、elasticsearch、MQ、依赖接口等等 做服务隔离或降级)</p>
</li>
<li><p><code>对外提供接口层面</code>：</p>
</li>
<li><p><code>mysql或存储</code>层面:</p>
</li>
</ul>
<p>##2.分布式服务故障</p>
<ul>
<li><code>zookeeper层面</code>：需要5各节点以上 做跨机房,注册中心需要不能宕机一半节点，5台的话 2/2/1分3个网段分配</li>
<li><code>rpc层面</code>: dubbo应该可以跨机房或网段部署</li>
<li><code>MQ层面</code>：</li>
<li><code>线程池层面</code>：</li>
</ul>
<blockquote>
<p>故障分析</p>
</blockquote>
<pre><code>1.tsar分析：https://github.com/alibaba/tsar/blob/master/info.md
2.jvm分析：jmap jstack jdump(系统故障前后做jvm的jdump，需要开启gc log)
    -XX:+PrintGCDetails 
    -XX:+PrintGCDateStamps 
    -Xloggc:/data/logs/vrs-es-provider/gc.log 
    -XX:+PrintClassHistogramBeforeFullGC 
    -XX+PrintClassHistogramAfterFullGC
    -XX:+UseCMSCompactAtFullCollection
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/05/(7.3).分布式架构-RocketMq/" itemprop="url">
                  消息队列-RocketMq
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-05T18:48:02+08:00" content="2016-06-05">
              2016-06-05
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index">
                    <span itemprop="name">MQ</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="存储存"><a href="#存储存" class="headerlink" title="存储存"></a>存储存</h2><h2 id="通信存"><a href="#通信存" class="headerlink" title="通信存"></a>通信存</h2><h2 id="NameServer"><a href="#NameServer" class="headerlink" title="NameServer"></a>NameServer</h2><h2 id="broker"><a href="#broker" class="headerlink" title="broker"></a>broker</h2><h2 id="producer"><a href="#producer" class="headerlink" title="producer"></a>producer</h2><h2 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h2><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>待补充</p>
<p>kafka:<a href="http://kafka.apache.org/documentation.html" target="_blank" rel="external">http://kafka.apache.org/documentation.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/03/(6.2).网络通讯-IO/" itemprop="url">
                  (6).网络通讯-IO/NIO/AIO
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-03T14:58:01+08:00" content="2016-06-03">
              2016-06-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/IO/" itemprop="url" rel="index">
                    <span itemprop="name">IO</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>待补充……</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/(6.1).多线程-并发编程/" itemprop="url">
                  并发编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T10:52:03+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/多线程/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="并发基本概念"><a href="#并发基本概念" class="headerlink" title="并发基本概念"></a>并发基本概念</h2><h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a><code>JMM内存模型</code></h3><blockquote>
<p>Java内存模型图</p>
</blockquote>
<p><img src="http://i1.itc.cn/20160523/aac_377efa19_9fb4_a50b_2593_627c07e9d791_1.png" alt="内存模型图"></p>
<p>可以对应到这张内存模型图：<br><img src="http://i0.itc.cn/20160523/aac_377efa19_9fb4_a50b_2593_627c07e9d791_2.jpg" alt="缓存模型"></p>
<p>这两张图告诉我们在线程运行的时候有一小块专用的内存空间，当Java程序会将变量同步到线程所在的内存，这时候会操作<code>工作内存</code>中的变量，而线程中变量的值何时同步回<code>主内存</code>是不可预期的。但同时Java内存模型又告诉我们通过使用关键词“synchronized”或“volatile”可以让 Java保证某些约束：</p>
<pre><code>“volatile” — 保证读写的都是主内存的变量
“synchronized” — 保证在块开始时都同步主内存的值到工作内存，而块结束时将变量同步回主内存.
</code></pre><blockquote>
<p>工作内存(本地内存)是什么，数据存在哪里? </p>
</blockquote>
<ul>
<li>1、java内存模型的抽象概念</li>
<li><p>2、并不在堆中，而是在cpu中的物理cache</p>
<pre><code>Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它的核心
思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的
副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这
个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
</code></pre></li>
</ul>
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/06/02/(6.1).多线程-并发编程/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/02/(6.3).缓存-redis/" itemprop="url">
                  redis
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T10:52:03+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式/缓存/" itemprop="url" rel="index">
                    <span itemprop="name">缓存</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redis初识"><a href="#redis初识" class="headerlink" title="redis初识"></a>redis初识</h2><h3 id="八大特性"><a href="#八大特性" class="headerlink" title="八大特性"></a>八大特性</h3><blockquote>
<p>特点:</p>
</blockquote>
<ul>
<li>速度快(c语言编写;数据存储全内存)</li>
<li>持久化(断电后不丢失数据,对数据的更新将异步地保存到磁盘上)</li>
<li>支持多种语言（java/php/ruby/lua/nodejs…）</li>
<li>支持多种数据结构(string/hash/list/set/zset)</li>
<li>功能丰富(除支持5种数据结构，还支持事务、流水线、发布订阅等)</li>
<li>“简单”(redis代码精简代码只有几万行；不依赖外部库资源)</li>
<li>主从复制(数据备份)</li>
<li>高可用、分布式（支持redis-sentinel高可用、redis-cluster分布式架构）</li>
</ul>
<blockquote>
<p>访问介质开销：</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160617/aac_181f16ac_2f7a_1a2a_fc4c_c7047525a146_3.png" alt=""></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="http://i0.itc.cn/20160617/aac_181f16ac_2f7a_1a2a_fc4c_c7047525a146_1.png" alt=""></p>
<ul>
<li>String(字符串)</li>
</ul>
<p>1).结构：<br><img src="http://i0.itc.cn/20160616/aac_d1bd8f2f_0e3f_f448_3a84_4d70ce62c237_2.png" alt=""></p>
<p>2).场景：缓存/计数器/分布式锁(单线程执行，QPS最大能达到10w+) </p>
<p>3).api命令：</p>
<pre><code>get/set/del (缓存)
Incr/decr/Incrby/decrby(计数，加+-1/+-n)
set/setnx/setxx
mset/mget （批量读取）
getset/append/strlen/Incrbyfloat/getrange/setrange（其他字符串操作）
</code></pre><ul>
<li>Hash(哈希)</li>
</ul>
<p>1).结构:<br><img src="http://i0.itc.cn/20160616/aac_838af662_24ad_42d8_6410_7810a64b2ded_5.png" alt=""></p>
<p>2).场景:缓存</p>
<p>3).api命令：</p>
<pre><code>hget/hset/hgetall/hdel(单条操作)
hexists/hlen（存在/长度）
hmget/hmset(批量设置/获取KV)
hgetall/hvals/hkeys(批量获取键值)
</code></pre><p><img src="http://i1.itc.cn/20160616/aac_838af662_24ad_42d8_6410_7810a64b2ded_4.png" alt=""></p>
<ul>
<li>List(列表)</li>
</ul>
<p>1).结构<br><img src="http://i0.itc.cn/20160616/aac_838af662_24ad_42d8_6410_7810a64b2ded_3.png" alt=""></p>
<p>2).场景:</p>
<p>3).api:</p>
<p><img src="http://i1.itc.cn/20160616/aac_838af662_24ad_42d8_6410_7810a64b2ded_2.png" alt=""></p>
<ul>
<li>Set(集合)</li>
<li>ZSet(有序集合)</li>
</ul>
<h3 id="redis命令-配置"><a href="#redis命令-配置" class="headerlink" title="redis命令/配置"></a>redis命令/配置</h3><blockquote>
<p>下载和安装</p>
</blockquote>
<pre><code>1. http://download.redis.io/releases/redis-3.0.5.tar.gz
2. tar xzf redis-3.0.5.tar.gz
3. cd redis-3.0.5
4. make
5. make install
</code></pre><blockquote>
<p>redis相关命令</p>
</blockquote>
<pre><code>服务器按配置启动：redis-server confdir
客户端连接：redis-cli -h ip -p port
查看服务端所有参数配置：cat redis.conf | grep -v &quot;#&quot; | grep -v &quot;^$&quot; | wc -l
</code></pre><blockquote>
<p>redis-cli返回值种类</p>
</blockquote>
<pre><code>状态回复：ping --&gt; pong
错误回复：wrongtype operation against
整数回复：(integer)1
字符串回复：&quot;world&quot;
多行字符串回复：&quot;hello&quot; &quot;world&quot;
空值回复：&quot;nil&quot;
</code></pre><blockquote>
<p>redis-server配置：</p>
</blockquote>
<pre><code>daemonize：是否是守护进程(no|yes)
port：Redis对外端口号
logfile：Redis系统日志
pidfile：保存进程号的文件
</code></pre><p>object类型<br><img src="http://i1.itc.cn/20160616/aac_838af662_24ad_42d8_6410_7810a64b2ded_1.png" alt=""></p>
<h3 id="aof-rdb持久化"><a href="#aof-rdb持久化" class="headerlink" title="aof/rdb持久化"></a>aof/rdb持久化</h3><h2 id="redis客户端使用"><a href="#redis客户端使用" class="headerlink" title="redis客户端使用"></a>redis客户端使用</h2><blockquote>
<p>jedis客户端</p>
</blockquote>
<h2 id="redis高可用、分布式架构"><a href="#redis高可用、分布式架构" class="headerlink" title="redis高可用、分布式架构"></a>redis高可用、分布式架构</h2><h3 id="redis-sentiler架构"><a href="#redis-sentiler架构" class="headerlink" title="redis-sentiler架构"></a>redis-sentiler架构</h3><p><img src="http://i0.itc.cn/20160616/aac_d723e707_cc35_ac96_003d_54bf115f5dfd_1.png" alt=""></p>
<blockquote>
<p>集群特点</p>
</blockquote>
<ul>
<li>1)节点自动发现</li>
<li>2):slave-&gt;master 选举,集群容错</li>
<li>3):Hot resharding:在线分片</li>
<li>4):进群管理:cluster xxx</li>
<li>5):基于配置(nodes-port.conf)的集群管理</li>
<li>6):ASK 转向/MOVED 转向机制.</li>
</ul>
<blockquote>
<p>Redis Sentinel故障转移</p>
</blockquote>
<p><img src="http://i0.itc.cn/20160616/aac_d723e707_cc35_ac96_003d_54bf115f5dfd_2.png" alt=""></p>
<h3 id="redis-cluster架构"><a href="#redis-cluster架构" class="headerlink" title="redis-cluster架构"></a>redis-cluster架构</h3><p><img src="http://i0.itc.cn/20160617/aac_181f16ac_2f7a_1a2a_fc4c_c7047525a146_5.png" alt="redis-cluster架构"></p>
<p><code>无中心化</code>智能管理:（每个主节点都知道其他节点信息）</p>
<p><img src="http://i2.itc.cn/20160616/aac_d723e707_cc35_ac96_003d_54bf115f5dfd_3.png" alt=""></p>
<p>架构细节:</p>
<pre><code>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.
(2)节点的fail是通过集群中超过半数的节点检测失效时才生效.
(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可
(4)redis-cluster把所有的物理节点映射到16383个slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value
</code></pre><p><code>槽指派</code>：(分16384个槽，用于数据)</p>
<p><img src="http://i1.itc.cn/20160616/aac_2ab7ff75_f2ac_f662_5af5_f71b41c66f33_1.png" alt=""></p>
<h2 id="codis架构"><a href="#codis架构" class="headerlink" title="codis架构"></a>codis架构</h2><p>##参考</p>
<pre><code>redis常用命令 http://doc.redisfans.com/
redis官网：http://redis.io/
redis学习文档：
redis学习视频：http://my.tv.sohu.com/pl/9102138/index.shtml
相关文章：
    [Redis 集群方案介绍](http://mp.weixin.qq.com/s?__biz=MzA3MzYwNjQ3NA==&amp;mid=2651296671&amp;idx=1&amp;sn=366de50a6787963517ff6e096c9d1643&amp;scene=2&amp;srcid=0601j5sEtcRyw9TtehhXW0Ix&amp;from=timeline&amp;isappinstalled=0#wechat_redirect)
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/metor.ico"
               alt="Pedestrian" />
          <p class="site-author-name" itemprop="name">Pedestrian</p>
          <p class="site-description motion-element" itemprop="description">study for goal</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">60</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">59</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yanan0628" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://carlosfu.github.io/" target="_blank" title="fudada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  fudada
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://jolinzhangg.github.io/" target="_blank" title="xiaodada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  xiaodada
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pedestrian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
