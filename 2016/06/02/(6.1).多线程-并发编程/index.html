<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="jmm,lock,juc,线程池,阻塞队列," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="并发基本概念JMM内存模型 Java内存模型图   可以对应到这张内存模型图： 这两张图告诉我们在线程运行的时候有一小块专用的内存空间，当Java程序会将变量同步到线程所在的内存，这时候会操作工作内存中的变量，而线程中变量的值何时同步回主内存是不可预期的。但同时Java内存模型又告诉我们通过使用关键词“synchronized”或“volatile”可以让 Java保证某些约束： “volatil">
<meta name="keywords" content="jmm,lock,juc,线程池,阻塞队列">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程">
<meta property="og:url" content="/2016/06/02/(6.1).多线程-并发编程/index.html">
<meta property="og:site_name" content="Meteor">
<meta property="og:description" content="并发基本概念JMM内存模型 Java内存模型图   可以对应到这张内存模型图： 这两张图告诉我们在线程运行的时候有一小块专用的内存空间，当Java程序会将变量同步到线程所在的内存，这时候会操作工作内存中的变量，而线程中变量的值何时同步回主内存是不可预期的。但同时Java内存模型又告诉我们通过使用关键词“synchronized”或“volatile”可以让 Java保证某些约束： “volatil">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i1.itc.cn/20160523/aac_377efa19_9fb4_a50b_2593_627c07e9d791_1.png">
<meta property="og:image" content="http://i0.itc.cn/20160523/aac_377efa19_9fb4_a50b_2593_627c07e9d791_2.jpg">
<meta property="og:image" content="http://i3.itc.cn/20160630/aac_8372eaf8_34b5_cc7a_069e_557ce48998bc_2.png">
<meta property="og:image" content="http://i3.itc.cn/20160630/aac_8372eaf8_34b5_cc7a_069e_557ce48998bc_1.png">
<meta property="og:image" content="http://i0.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_5.png">
<meta property="og:image" content="http://i3.itc.cn/20160707/aac_25d1aae0_7aac_20cf_ea7e_19529818657a_3.png">
<meta property="og:image" content="http://i3.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_4.png">
<meta property="og:image" content="http://i2.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_1.png">
<meta property="og:image" content="http://i1.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_3.png">
<meta property="og:image" content="http://i0.itc.cn/20160630/aac_3fe63360_2218_b4e0_56d4_89a2c3216c58_3.jpg">
<meta property="og:image" content="http://i2.itc.cn/20160630/aac_3fe63360_2218_b4e0_56d4_89a2c3216c58_2.png">
<meta property="og:image" content="http://i3.itc.cn/20160630/aac_3fe63360_2218_b4e0_56d4_89a2c3216c58_1.png">
<meta property="og:image" content="http://i1.itc.cn/20160630/aac_468c58c2_3765_9b1a_f179_e0e5297c4e6e_1.png">
<meta property="og:image" content="http://i0.itc.cn/20160630/aac_a0b2b4a4_5abf_cf47_8617_a0ac18be5545_1.jpg">
<meta property="og:updated_time" content="2016-09-07T02:08:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="并发编程">
<meta name="twitter:description" content="并发基本概念JMM内存模型 Java内存模型图   可以对应到这张内存模型图： 这两张图告诉我们在线程运行的时候有一小块专用的内存空间，当Java程序会将变量同步到线程所在的内存，这时候会操作工作内存中的变量，而线程中变量的值何时同步回主内存是不可预期的。但同时Java内存模型又告诉我们通过使用关键词“synchronized”或“volatile”可以让 Java保证某些约束： “volatil">
<meta name="twitter:image" content="http://i1.itc.cn/20160523/aac_377efa19_9fb4_a50b_2593_627c07e9d791_1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> 并发编程 | Meteor </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Meteor</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                并发编程
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-06-02T10:52:03+08:00" content="2016-06-02">
              2016-06-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/多线程/" itemprop="url" rel="index">
                    <span itemprop="name">多线程</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/多线程/JUC/" itemprop="url" rel="index">
                    <span itemprop="name">JUC</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="并发基本概念"><a href="#并发基本概念" class="headerlink" title="并发基本概念"></a>并发基本概念</h2><h3 id="JMM内存模型"><a href="#JMM内存模型" class="headerlink" title="JMM内存模型"></a><code>JMM内存模型</code></h3><blockquote>
<p>Java内存模型图</p>
</blockquote>
<p><img src="http://i1.itc.cn/20160523/aac_377efa19_9fb4_a50b_2593_627c07e9d791_1.png" alt="内存模型图"></p>
<p>可以对应到这张内存模型图：<br><img src="http://i0.itc.cn/20160523/aac_377efa19_9fb4_a50b_2593_627c07e9d791_2.jpg" alt="缓存模型"></p>
<p>这两张图告诉我们在线程运行的时候有一小块专用的内存空间，当Java程序会将变量同步到线程所在的内存，这时候会操作<code>工作内存</code>中的变量，而线程中变量的值何时同步回<code>主内存</code>是不可预期的。但同时Java内存模型又告诉我们通过使用关键词“synchronized”或“volatile”可以让 Java保证某些约束：</p>
<pre><code>“volatile” — 保证读写的都是主内存的变量
“synchronized” — 保证在块开始时都同步主内存的值到工作内存，而块结束时将变量同步回主内存.
</code></pre><blockquote>
<p>工作内存(本地内存)是什么，数据存在哪里? </p>
</blockquote>
<ul>
<li>1、java内存模型的抽象概念</li>
<li><p>2、并不在堆中，而是在cpu中的物理cache</p>
<pre><code>Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它的核心
思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的
副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这
个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="volitile-final-synchronized关键字"><a href="#volitile-final-synchronized关键字" class="headerlink" title="volitile,final,synchronized关键字"></a><code>volitile</code>,<code>final</code>,<code>synchronized</code>关键字</h3><blockquote>
<p>volitile语义</p>
</blockquote>
<pre><code>用来对共享变量的访问进行同步，上一次写入操作的结果对下一次读取操作是肯定可见的。（在写
入volatile变量值之后，CPU缓存中的内容会被写回内存；在读取volatile变量时，CPU缓存中的
对应内容会被置为失效，重新从主存中进行读取），volatile不使用锁，性能优于synchronized关键词。
</code></pre><blockquote>
<p>synchronized语义</p>
</blockquote>
<pre><code>方法或代码块的互斥性来完成实际上的一个原子操作。（方法或代码块在被一个线程调用时，其他
线程处于等待状态），所有的Java对象都有一个与synchronzied关联的监视器对（monitor），
允许线程在该监视器对象上进行加锁和解锁操作。
a、静态方法：Java类对应的Class类的对象所关联的监视器对象。
b、实例方法：当前对象实例所关联的监视器对象。
c、代码块：代码块声明中的对象所关联的监视器对象。
</code></pre><blockquote>
<p>final语义</p>
</blockquote>
<pre><code>final关键词声明的域的值只能被初始化一次，一般在构造方法中初始化。（在多线程开发中，
final域通常用来实现不可变对象）当对象中的共享变量的值不可能发生变化时，在多线程中也
就不需要同步机制来进行处理，故在多线程开发中应尽可能使用不可变对象。另外，在代码执行
时，final域的值可以被保存在寄存器中,而不用从主存中频繁重新读取。
</code></pre><h2 id="线程状态及流程"><a href="#线程状态及流程" class="headerlink" title="线程状态及流程"></a>线程状态及流程</h2><h3 id="线程流程图"><a href="#线程流程图" class="headerlink" title="线程流程图"></a>线程流程图</h3><blockquote>
<p>线程的几种状态</p>
</blockquote>
<p>Java线程一共有七个状态，分别是<code>新建(new)</code>，<code>可运行(ready)</code>，<code>运行中(running)</code>，<code>睡眠(sleep,是一种time_waiting超时等待)</code>，<code>阻塞（blocked）</code>，<code>等待(waiting等待被唤醒)</code>，<code>死亡（terminated）</code>.</p>
<ul>
<li><p>状态解释<br><img src="http://i3.itc.cn/20160630/aac_8372eaf8_34b5_cc7a_069e_557ce48998bc_2.png" alt=""></p>
</li>
<li><p>状态切换<br><img src="http://i3.itc.cn/20160630/aac_8372eaf8_34b5_cc7a_069e_557ce48998bc_1.png" alt="线程状态变迁"></p>
</li>
</ul>
<p><code>wait/join</code></p>
<p>wait:如果没有线程中断，让出cpu给其他线程执行机会，进入waiting/time_waiting状态；基于Object监视器，需要配合synchronized,lock使用,可实现等待/通知；会释放锁进行wait队列</p>
<p>join:如果没有线程中断，就一直执行完当前线程任务，其他线程等待 其执行完 才能执行；</p>
<p>sleep:如果线程没有中断，进入time_waiting状态，等时间到可恢复执行；基于线程thread对象；不会释放对象锁</p>
<blockquote>
<p> deamon线程/threadlocal/线程中断</p>
</blockquote>
<ul>
<li><p>deamon线程</p>
<p>  Deamon线程是一种支持型线程，当java虚拟机不存在非deamon线程的时候，java虚拟机会自动退出。使用方式 Thread.setDeamon(true),注意：在构建Deamon线程是，不能依靠finally块的内容来确保执行关闭和清理资源，因为deamon线程立即终止特性，可能不会执行或执行完成。</p>
</li>
<li><p>线程中断</p>
<p>  中断可以理解为线程的一个标志位，它表示一个运行中的线程是否能呗其他线程进行中断操作。<br>  像 sleep(),wait()，LOCK 都是可被中断的, synochronzie 不能被中断。</p>
<p>  如何优雅终止线程：通过状态作为开关去控制<br>  shutdown/shutdownNow: 线程池进行中断<br>  interrupt: 单个线程中断<br>  标志位： 通过标志位中断</p>
</li>
<li><p>threadlocal线程变量</p>
<p>  threadLocal即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。</p>
</li>
<li><p>ShutdownHook友好地清理现场</p>
</li>
</ul>
<h3 id="object监视器方法-和-condition接口"><a href="#object监视器方法-和-condition接口" class="headerlink" title="object监视器方法 和 condition接口"></a>object监视器方法 和 condition接口</h3><blockquote>
<p>等待队列  waitQueue/synchronzieQueue</p>
</blockquote>
<p><strong>Object.wait()使用监视器的SynchronzieQueue队列</strong><br><img src="http://i0.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_5.png" alt="对象-监视器-同步队列-线程间关系"></p>
<p><img src="http://i3.itc.cn/20160707/aac_25d1aae0_7aac_20cf_ea7e_19529818657a_3.png" alt="wait-synchronize队列使用"></p>
<blockquote>
<p>等待/通知模式 </p>
</blockquote>
<p>特点：1</p>
<pre><code>Object对象：任何一个java对象都拥有监视器方法 需要结合synchronized同步字使用  
    wait()
    wait(time)
    notify()
    notifyall()

condition接口：
    await()
    awaitUninterruptibly()
    awaitNanos(long)
    await(long, TimeUnit)
    awaitUntil(Date)
    signal()
    signalAll()
</code></pre><p>监视器和condition使用对比：<br><img src="http://i3.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_4.png" alt="object Monitor与condition对比"></p>
<h3 id="线程应用实例"><a href="#线程应用实例" class="headerlink" title="线程应用实例"></a>线程应用实例</h3><h4 id="等待超时模式-像dubbo，rocketmq-hystrix架构会应用该模式"><a href="#等待超时模式-像dubbo，rocketmq-hystrix架构会应用该模式" class="headerlink" title="等待超时模式(像dubbo，rocketmq,hystrix架构会应用该模式)"></a>等待超时模式(像dubbo，rocketmq,hystrix架构会应用该模式)</h4><p>~~伪代码</p>
<pre><code>lock.lock();
while(结果未返回){
    //等待结果返回的通知,需要有其他线程进行notify notifyAll signal signalAll来通知结束等待
    wait(timeout);// condition.await(timeout)
    if(结果返回或超时){
         break;
    }
}
lock.unlock();
if(结果返回){
    判断是否超时?正常返回:返回超时状态;
}
</code></pre><p>dubbo超时实现：</p>
<p>~~java</p>
<pre><code>public Object get(int timeout) throws RemotingException {
        if (timeout &lt;= 0) {
            timeout = Constants.DEFAULT_TIMEOUT;
        }
        if (! isDone()) {
            long start = System.currentTimeMillis();
            lock.lock();
            try {
                //如果唤醒后 未完成且未超时 ，会循环进行死等！！
                while (! isDone()) {
                    done.await(timeout, TimeUnit.MILLISECONDS);
                    if (isDone() || System.currentTimeMillis() - start &gt; timeout) {
                        break;
                    }
                }
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                lock.unlock();
            }
            //未完成则超时
            if (! isDone()) {
                throw new TimeoutException(sent &gt; 0, channel, getTimeoutMessage(false));
            }
        }
        return returnFromResponse();
    }  
</code></pre><h4 id="简单数据库连接池"><a href="#简单数据库连接池" class="headerlink" title="简单数据库连接池"></a>简单数据库连接池</h4><h3 id="线程堆栈分析jstack-trace"><a href="#线程堆栈分析jstack-trace" class="headerlink" title="线程堆栈分析jstack trace"></a>线程堆栈分析jstack trace</h3><h4 id="jstack堆栈的状态信息"><a href="#jstack堆栈的状态信息" class="headerlink" title="jstack堆栈的状态信息"></a>jstack堆栈的状态信息</h4><p>可参考分析：<a href="http://www.cnblogs.com/nexiyi/p/java_thread_jstack.html" target="_blank" rel="external">http://www.cnblogs.com/nexiyi/p/java_thread_jstack.html</a></p>
<blockquote>
<p>死锁-deadlock （BLOCKED）</p>
</blockquote>
<p><img src="http://i2.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_1.png" alt=""></p>
<blockquote>
<p>等待资源-Waiting on condition (TIME_WAITING)，<code>sleep(time),join(time),park(time)</code> —AQS实现的锁</p>
</blockquote>
<pre><code>&quot;Blocked-2-thread&quot; prio=6 tid=0x000000000e6c5000 nid=0x2bf8 waiting on condition [0x000000000f02f000]
   java.lang.Thread.State: WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  &lt;0x00000007c1b23a60&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)
        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
</code></pre><blockquote>
<p>等待获取监视器-Waiting on monitor entry(WAITING)，<code>object.wait()进行等待</code>—Synchronized关键字</p>
</blockquote>
<pre><code>&quot;Blocked-1-thread&quot; prio=6 tid=0x000000000e6c4000 nid=0x2fa4 waiting on condition [0x000000000df9f000]
   java.lang.Thread.State: TIMED_WAITING (sleeping)
        at java.lang.Thread.sleep(Native Method)
        at java.lang.Thread.sleep(Thread.java:340)
        at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:360)
        at com.sohu.train.thread.base.ThreadState$Blocked.run(ThreadState.java:86)
        at java.lang.Thread.run(Thread.java:744)
</code></pre><blockquote>
<p>阻塞-BLOCKED (BLOCKED)，<code>synchronized同步锁会阻塞其他线程</code></p>
</blockquote>
<pre><code>&quot;Blocked-2-thread&quot; prio=6 tid=0x000000000e7b4000 nid=0x2344 waiting for monitor entry [0x000000000f43f000]
   java.lang.Thread.State: BLOCKED (on object monitor)
        at com.sohu.train.thread.base.ThreadState$Blocked.run(ThreadState.java:77)
        - waiting to lock &lt;0x00000007c1b28a20&gt; (a java.lang.Class for com.sohu.train.thread.base.ThreadState$Blocked)
        at java.lang.Thread.run(Thread.java:744)
</code></pre><blockquote>
<p>暂停-parking （WAITING/TIME_WAITING）,`lock锁实现是基于</p>
<p>做等待或阻塞线程`</p>
</blockquote>
<pre><code>lockSupport工具静态方法:
    unpark(Thread) 
    park(Object)
    parkNanos(Object, long)
    parkUntil(Object, long)
    park()
    parkNanos(long)
    parkUntil(long) 
</code></pre><p><img src="http://i1.itc.cn/20160706/aac_36f1f1d8_7130_1bf2_50f2_53af4dc6c963_3.png" alt="Locksupport阻塞和唤醒方法"></p>
<h2 id="CAS原子操作类"><a href="#CAS原子操作类" class="headerlink" title="CAS原子操作类"></a>CAS原子操作类</h2><p><strong>原子操作是指一个不受其他操作影响的操作任务单元</strong>。原子操作是在多线程环境下避免数据不一致必须的手段。int++并不是一个原子操作，所以当一个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。为了解决这个问题，必须保证增加操作是原子的，在JDK1.5之前我们可以使用同步技术来做到这一点。到JDK1.5，java.util.concurrent.atomic包提供了int和long类型的装类，它们可以自动的保证对于他们的操作是原子的并且不需要使用同步。</p>
<p>参考: <a href="http://ifeve.com/locks-are-bad/" target="_blank" rel="external">剖析Disruptor为什么会这么快?</a></p>
<h2 id="AQS同步框架"><a href="#AQS同步框架" class="headerlink" title="AQS同步框架"></a>AQS同步框架</h2><p>作为同步基础框架，需要提供：维护一个<code>同步状态</code>（表示锁被锁定或释放），包含对状态的更新和检查操作，包含能够阻塞当前线程的方法，其他线程修改同步状态后能恢复。</p>
<h3 id="概念混淆"><a href="#概念混淆" class="headerlink" title="概念混淆"></a>概念混淆</h3><ul>
<li>活锁和死锁（区别在于能不能自己解开）</li>
<li><p>独占和共享 (是否可以被多个线程获取)</p>
<p>ReentrantLock是独占锁,可理解为写锁；Semaphore信号量是共享锁,可理解为读锁</p>
</li>
<li><p>闭锁、屏障、信号量</p>
<p>闭锁和屏障相似，就像们一样，到齐了就放，区别在于能否多次使用，闭锁就是一锤子买卖，用完就完了；信号量和闭锁的区别是，是否是共享的，信号量是共享锁，多个同时获取锁，闭锁理论上还是算排他的，虽然countdown的过程是多个线程，但其实之后到0以后才算是是否锁定的</p>
</li>
<li><p>自旋锁(自循环判断)</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">for (;;) &#123; // 死循环，自旋锁，节点自旋获取同步状态</div><div class="line">....</div><div class="line">if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</div><div class="line">               interrupted = true;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>乐观锁和悲观锁(获取锁的一种态度，乐观锁认为能获取，悲观锁)</p>
</li>
<li><p>互斥锁和排它锁</p>
</li>
<li><p>可重入锁和不可重入锁(判断是否可以再次使用，看是否是自身)</p>
<p>if (current == getExclusiveOwnerThread())  true:重入锁  false:不可重入锁</p>
</li>
</ul>
<h3 id="AQS需满足的三要素"><a href="#AQS需满足的三要素" class="headerlink" title="AQS需满足的三要素"></a>AQS需满足的三要素</h3><ul>
<li>自动维护同步状态</li>
</ul>
<p>Synchronization State，是32位的int，使用volatile保证state在线程间可见，并通过CAS操作完成更新，保证变量的同步。compareAndSetState与期望值对比，相同才更新.</p>
<ul>
<li>阻塞和唤醒线程</li>
</ul>
<p>Blocking，提供<code>独占（ReentrantLock）</code>和<code>共享模式（Semaphore）</code>，以及同时包含<code>两种模式的ReentrantReadWriteLock</code>。</p>
<ul>
<li>维护队列</li>
</ul>
<p>Queue，框架的核心就是维护的这个包含阻塞线程的队列。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><blockquote>
<p>锁概念</p>
</blockquote>
<p>提供和synchronized关键字类似的同步功能，只是使用的时候需要显示地获取和释放锁。但是可以解决synchronized关键字不太容易解决的内置锁交叉的情况。同时，<strong>具备尝试非阻塞地获取锁；能被中断地获取锁，超时获取锁</strong>（有些需要通过线程中断处理 线程池交换处理任务，jmx可暴露 接口启动线程池）。</p>
<pre><code>如:     lock A
        lock B
        unlock A
        lock C
        unlock B
        unlock C
        ......
</code></pre><p>Lock的使用方式：</p>
<pre><code>Lock lock = new ReentrantLock()；
lock.lock();//为什么写在try{}catch外层，防止自己实现aqs框架 lock可能会抛出异常
try {
}catch(Exception e){
    ...
} finally {
    lock.unlock();  // 要在finally中释放锁，保证出现异常也能释放

}
</code></pre><h3 id="condition"><a href="#condition" class="headerlink" title="condition"></a>condition</h3><h3 id="队列同步器AbstractQueuedSynchronizer（AQS）"><a href="#队列同步器AbstractQueuedSynchronizer（AQS）" class="headerlink" title="队列同步器AbstractQueuedSynchronizer（AQS）"></a>队列同步器AbstractQueuedSynchronizer（AQS）</h3><h2 id="并发容器和框架"><a href="#并发容器和框架" class="headerlink" title="并发容器和框架"></a>并发容器和框架</h2><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p> 在新增的Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列 类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭中的所有成员，包括他们各自的功能以及常见使用场景。</p>
<blockquote>
<p>BlockingQueue的核心方法</p>
</blockquote>
<pre><code>放入数据：
　　offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即如果BlockingQueue可以容纳,
　　　　则返回true,否则返回false.（本方法不阻塞当前执行方法的线程）
　　offer(E o, long timeout, TimeUnit unit),可以设定等待的时间，如果在指定的时间内，还不能往队列中
　　　　加入BlockingQueue，则返回失败。
　　put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有空间,则调用此方法的线程被阻断
　　　　直到BlockingQueue里面有空间再继续.
获取数据：
　　poll(time):取走BlockingQueue里排在首位的对象,若不能立即取出,则可以等time参数规定的时间,
　　　　取不到时返回null;
　　poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，如果在指定时间内，
　　　　队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。
　　take():取走BlockingQueue里排在首位的对象,若BlockingQueue为空,阻断进入等待状态直到
　　　　BlockingQueue有新的数据被加入; 
　　drainTo():一次性从BlockingQueue获取所有可用的数据对象（还可以指定获取数据的个数）， 
　　　　通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。
</code></pre><blockquote>
<p>常用阻塞队列（参考：<a href="http://blog.csdn.net/ydj7501603/article/details/17246949）" target="_blank" rel="external">http://blog.csdn.net/ydj7501603/article/details/17246949）</a></p>
</blockquote>
<p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p>可参考: <a href="http://ifeve.com/%e3%80%8a-java%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e3%80%8b%e7%ac%ac5%e7%ab%a0-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%b9%8b%e9%97%b4%e4%ba%a4%e4%ba%92/" target="_blank" rel="external">并发艺术-阻塞队列</a></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>阻塞队列提供了四种处理方法:</p>
<table>
<thead>
<tr>
<th>方法\处理方式</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th style="text-align:center">一直阻塞</th>
<th style="text-align:center">超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入方法(e)</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">put(e)</td>
<td style="text-align:center">offer(e,time,unit)</td>
</tr>
<tr>
<td>移除方法</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take()</td>
<td style="text-align:center">poll(time,unit)</td>
</tr>
<tr>
<td>检查方法</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>抛出异常</strong>：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li>
<li><strong>返回特殊值</strong>：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li>
<li><strong>一直阻塞</strong>：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li>
<li><strong>超时退出</strong>：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li>
</ul>
<h3 id="jdk中的7种阻塞队列"><a href="#jdk中的7种阻塞队列" class="headerlink" title="jdk中的7种阻塞队列"></a>jdk中的7种阻塞队列</h3><p><code>linkedBlockingQueue</code>和<code>ArrayBlockingQueue</code>比较：</p>
<pre><code>LinkedBlockingQueue是BlockingQueue的一种使用Link List的实现，它对头和尾（取和添加
操作）采用两把不同的锁，相对于ArrayBlockingQueue提高了吞吐量。它也是一种阻塞型的容
器，适合于实现“消费者生产者”模式。
ArrayBlockingQueue是对BlockingQueue的一个数组实现，它使用一把全局的锁并行对queue的
读写操作，同时使用两个Condition阻塞容量为空时的取操作和容量满时的写操作。
正因为LinkedBlockingQueue使用两个独立的锁控制数据同步，所以可以使存取两种操作并行执
行，从而提高并发效率。而ArrayBlockingQueue使用一把锁，造成在存取两种操作争抢一把锁，
而使得性能相对低下。LinkedBlockingQueue可以不设置队列容量，默认Integer.MAX_VALUE
其容易造成内存溢出，一般要设置其值。
</code></pre><ul>
<li><p>ArrayBlockingQueue</p>
<p> ArrayBlockingQueue一个由数组支持的<strong>有界的阻塞队列</strong>。此队列按 FIFO（先进先出）原则对元素进行排序。队列的头部 是在队列中存在时间最长的元素。队列的尾部 是在队列中存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。</p>
</li>
</ul>
<blockquote>
<p>源码</p>
</blockquote>
<pre><code>~~ java 基于 reetranLock锁 和 condition等待通知 实现

public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {

/** The queued items */
final Object[] items;

/** items index for next take, poll, peek or remove */
int takeIndex;

/** items index for next put, offer, or add */
int putIndex;

/** Number of elements in the queue */
int count;

/** Main lock guarding all access 用于阻塞其他线程 */
final ReentrantLock lock;
/** Condition for waiting takes   用于唤醒消费 */
private final Condition notEmpty;
/** Condition for waiting puts    用于唤醒生产 */
private final Condition notFull ;

/**
 * offer和poll一对，有返回值
 *
 * @throws NullPointerException if the specified element is null
 */
public boolean offer(E e) {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        if (count == items.length)
            return false;
        else {
            insert(e);//如果queue未满，添加元素，通知消费
            return true;
        }
    } finally {
        lock.unlock();
    }
}

 public E poll() {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        return (count == 0) ? null : extract();
    } finally {
        lock.unlock();
    }
}

/**
 *  put和take一对
 */
public void put(E e) throws InterruptedException {
    checkNotNull(e);
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();    //可中断锁
    try {
        while (count == items.length)
            notFull.await();    //如果queue满了，就会阻塞&quot;放&quot;的过程
        insert(e);
    } finally {
        lock.unlock();
    }
}

public E take() throws InterruptedException {
    final ReentrantLock lock = this.lock;
    lock.lockInterruptibly();
    try {
        while (count == 0)
            notEmpty.await();    //如果queue为空，就会阻塞&quot;取&quot;的过程
        return extract();        //queue不为空，就释放notEmpty
    } finally {
        lock.unlock();
    }
}

/**
 * Inserts element at current put position, advances, and signals.
 * Call only when holding lock.
 */
private void insert(E x) {
    items[putIndex] = x;
    putIndex = inc(putIndex);
    ++count;
    notEmpty.signal();            // 等待生产&quot;放&quot;入元素，唤醒 队列为空 的阻塞线程进行消费
}

 /**
 * Extracts element at current take position, advances, and signals.
 * Call only when holding lock.
 */
private E extract() {
    final Object[] items = this.items;
    E x = this.&lt;E&gt;cast(items[takeIndex]);
    items[takeIndex] = null;
    takeIndex = inc(takeIndex);
    --count;
    notFull.signal();            // 等待消费&quot;取&quot;出元素，唤醒 队列为满 的阻塞线程进行生产
    return x;
}
</code></pre><ul>
<li>LinkedBlockingQueue</li>
</ul>
<p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到<strong>最大值缓存容量</strong>时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。<br>作为开发者，<strong>我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</strong>（如果 生产者速度&gt;消费速度 ，队列会持续增大，会撑爆jvm内存）</p>
<blockquote>
<p>源码</p>
</blockquote>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {

    /**
     * Linked list node class，内部类：定义一个节点
     */
    static class Node&lt;E&gt; {
        E item;

        /**
         * One of:
         * - the real successor Node
         * - this Node, meaning the successor is head.next
         * - null, meaning there is no successor (this is the last node)
         */
        Node&lt;E&gt; next;

        Node(E x) { item = x; }
    }

    /** The capacity bound, or Integer.MAX_VALUE if none */
    private final int capacity;

    /** Current number of elements */
    private final AtomicInteger count = new AtomicInteger(0);

    /**
     * Head of linked list.
     * Invariant: head.item == null
     */
    private transient Node&lt;E&gt; head;

    /**
     * Tail of linked list.
     * Invariant: last.next == null
     */
    private transient Node&lt;E&gt; last;

    /** Lock held by take, poll, etc &quot;取&quot;锁 */
    private final ReentrantLock takeLock = new ReentrantLock();

    /** Wait queue for waiting takes  消费者阻塞通知 */
    private final Condition notEmpty = takeLock.newCondition();

    /** Lock held by put, offer, etc  &quot;放&quot;锁 */
    private final ReentrantLock putLock = new ReentrantLock();

    /** Wait queue for waiting puts  生产者阻塞通知 */
    private final Condition notFull = putLock.newCondition();

    /**
    *   put和take一套，分别用独立锁，比arraylistBlockingQueue并发性能更好
    */
    public void put(E e) throws InterruptedException {
    if (e == null) throw new NullPointerException();
    // Note: convention in all put/take/etc is to preset local var
    // holding count negative to indicate failure unless set.
    int c = -1;
    Node&lt;E&gt; node = new Node(e);
    final ReentrantLock putLock = this.putLock;
    final AtomicInteger count = this.count;
    putLock.lockInterruptibly();
    try {
        /*
         * Note that count is used in wait guard even though it is
         * not protected by lock. This works because count can
         * only decrease at this point (all other puts are shut
         * out by lock), and we (or some other waiting put) are
         * signalled if it ever changes from capacity. Similarly
         * for all other uses of count in other wait guards.
         */
        while (count.get() == capacity) {
            notFull.await();
        }
        enqueue(node);
        c = count.getAndIncrement();
        if (c + 1 &lt; capacity)
            notFull.signal();
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
}

public E take() throws InterruptedException {
    E x;
    int c = -1;
    final AtomicInteger count = this.count;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lockInterruptibly();
    try {
        while (count.get() == 0) {
            notEmpty.await();
        }
        x = dequeue();
        c = count.getAndDecrement();
        if (c &gt; 1)
            notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
    if (c == capacity)
        signalNotFull();
    return x;
}

/**
*  offer和poll是一对
*/
public boolean offer(E e) {
    if (e == null) throw new NullPointerException();
    final AtomicInteger count = this.count;
    if (count.get() == capacity)
        return false;
    int c = -1;
    Node&lt;E&gt; node = new Node(e);
    final ReentrantLock putLock = this.putLock;
    putLock.lock();
    try {
        if (count.get() &lt; capacity) {
            enqueue(node);
            c = count.getAndIncrement();
            if (c + 1 &lt; capacity)
                notFull.signal();
        }
    } finally {
        putLock.unlock();
    }
    if (c == 0)
        signalNotEmpty();
    return c &gt;= 0;
}

 public E poll() {
    final AtomicInteger count = this.count;
    if (count.get() == 0)
        return null;
    E x = null;
    int c = -1;
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        if (count.get() &gt; 0) {
            x = dequeue();
            c = count.getAndDecrement();
            if (c &gt; 1)
                notEmpty.signal();
        }
    } finally {
        takeLock.unlock();
    }
    if (c == capacity)
        signalNotFull();
    return x;
}

/**
 * Signals a waiting take. Called only from put/offer (which do not
 * otherwise ordinarily lock takeLock.)
 */
private void signalNotEmpty() {
    final ReentrantLock takeLock = this.takeLock;
    takeLock.lock();
    try {
        notEmpty.signal();
    } finally {
        takeLock.unlock();
    }
}

/**
 * Signals a waiting put. Called only from take/poll.
 */
private void signalNotFull() {
    final ReentrantLock putLock = this.putLock;
    putLock.lock();
    try {
        notFull.signal();
    } finally {
        putLock.unlock();
    }
}
</code></pre><ul>
<li>DelayQueue</li>
</ul>
<p>DelayQueue：是一个支持延时获取元素的使用优先级队列的实现的<strong>无界阻塞队列</strong>。队列中的元素必须实现Delayed接口和Comparable接口，也就是说DelayQueue里面的元素必须有public int compareTo( T o)和long getDelay(TimeUnit unit)方法存在，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将DelayQueue运用在以下应用场景：<br><strong>缓存系统的设计</strong>：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。<br><strong>定时任务调度</strong>。使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。</p>
<ul>
<li>PriorityBlockingQueue</li>
</ul>
<p>PriorityBlockingQueue ：一个支持优先级排序的<strong>无界阻塞队列</strong>（优先级的判断通过构造函数传入的Compator对象来决定），但需要注意的是<strong>PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p>
<ul>
<li>SynchronousQueue</li>
</ul>
<p>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。<br>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的行为。公平模式和非公平模式的区别:<br>如果采用公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；<br>但如果是非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。</p>
<h3 id="生产-消费者模型"><a href="#生产-消费者模型" class="headerlink" title="生产-消费者模型"></a>生产-消费者模型</h3><p>JDK BlockingQueue释义<code>生产-消费者</code>模型</p>
<p>~~ java</p>
<pre><code>/ ** &lt;p&gt;
* Usage example, based on a typical producer-consumer scenario.
* Note that a &lt;tt&gt;BlockingQueue&lt;/tt&gt; can safely be used with multiple
* producers and multiple consumers.
* &lt;pre&gt;
* class Producer implements Runnable {
*   private final BlockingQueue queue;
*   Producer(BlockingQueue q) { queue = q; }
*   public void run() {
*     try {
*       while (true) { queue.put(produce()); }
*     } catch (InterruptedException ex) { ... handle ...}
*   }
*   Object produce() { ... }
* }
*
* class Consumer implements Runnable {
*   private final BlockingQueue queue;
*   Consumer(BlockingQueue q) { queue = q; }
*   public void run() {
*     try {
*       while (true) { consume(queue.take()); }
*     } catch (InterruptedException ex) { ... handle ...}
*   }
*   void consume(Object x) { ... }
* }
*
* class Setup {
*   void main() {
*     BlockingQueue q = new SomeQueueImplementation();
*     Producer p = new Producer(q);
*     Consumer c1 = new Consumer(q);
*     Consumer c2 = new Consumer(q);
*     new Thread(p).start();
*     new Thread(c1).start();
*     new Thread(c2).start();
*   }
* }
* &lt;/pre&gt;
* /
</code></pre><h2 id="线程池分析"><a href="#线程池分析" class="headerlink" title="线程池分析"></a>线程池分析</h2><h3 id="流程及概念"><a href="#流程及概念" class="headerlink" title="流程及概念"></a>流程及概念</h3><blockquote>
<p> 为什么要使用线程池？</p>
</blockquote>
<ul>
<li><p>第一：降低资源消耗。</p>
<p>  通过重复利用已创建线程来降低线程创建和销毁造成的开销。(corePoolSize==MaxPoolSize)</p>
</li>
<li><p>第二：提高响应速度。</p>
<p>  当任务到达时，任务不需要等到线程创建就能立即执行。</p>
</li>
<li><p>第三：提高线程的管理性。</p>
<p>  线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p>
</li>
</ul>
<blockquote>
<p>执行流程</p>
</blockquote>
<p><img src="http://i0.itc.cn/20160630/aac_3fe63360_2218_b4e0_56d4_89a2c3216c58_3.jpg" alt="线程池执行流程图"></p>
<ul>
<li>首先线程池判断基本线程池是否已满？没满，创建一个</li>
<li></li>
<li></li>
<li>来执行任务。满了，则进入下个流程。</li>
<li>其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。</li>
<li>最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。</li>
</ul>
<p>线程池执行任务的方法如下：<br>~~</p>
<pre><code>public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    /*
     * Proceed in 3 steps:
     *
     * 1. If fewer than corePoolSize threads are running, try to
     * start a new thread with the given command as its first
     * task.  The call to addWorker atomically checks runState and
     * workerCount, and so prevents false alarms that would add
     * threads when it shouldn&apos;t, by returning false.
     *
     * 2. If a task can be successfully queued, then we still need
     * to double-check whether we should have added a thread
     * (because existing ones died since last checking) or that
     * the pool shut down since entry into this method. So we
     * recheck state and if necessary roll back the enqueuing if
     * stopped, or start a new thread if there are none.
     *
     * 3. If we cannot queue task, then we try to add a new
     * thread.  If it fails, we know we are shut down or saturated
     * and so reject the task.
     *
    1. 如果运行的线程数小于corePoolSize，则尝试新建一个线程，并设置当前的任务为该线程第一个需要处理的任务。
    2. 如果运行的线程数大于等于corePoolSize，则将该任务添加到阻塞队列workQueue中，池子中的空闲线程就会去队列汇总取任务之心。
    3. 当队列满了后，添加队列会失败，这是尝试直接创建一个线程，如果失败，可以得知，要么线程池已经关闭，要么是达到了饱和状态，不能在接受新任务，则该任务将被拒绝。    
    */
    int c = ctl.get();
    if (workerCountOf(c) &lt; corePoolSize) {
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        if (! isRunning(recheck) &amp;&amp; remove(command))
            reject(command);
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    else if (!addWorker(command, false))
        reject(command);
}
</code></pre><p>~~<br>工作线程。线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点：<br>~~</p>
<pre><code>/**
 * Main worker run loop.  Repeatedly gets tasks from queue and
 * executes them, while coping with a number of issues:
 *
 * 1. We may start out with an initial task, in which case we
 * don&apos;t need to get the first one. Otherwise, as long as pool is
 * running, we get tasks from getTask. If it returns null then the
 * worker exits due to changed pool state or configuration
 * parameters.  Other exits result from exception throws in
 * external code, in which case completedAbruptly holds, which
 * usually leads processWorkerExit to replace this thread.
 *
 * 2. Before running any task, the lock is acquired to prevent
 * other pool interrupts while the task is executing, and
 * clearInterruptsForTaskRun called to ensure that unless pool is
 * stopping, this thread does not have its interrupt set.
 *
 * 3. Each task run is preceded by a call to beforeExecute, which
 * might throw an exception, in which case we cause thread to die
 * (breaking loop with completedAbruptly true) without processing
 * the task.
 *
 * 4. Assuming beforeExecute completes normally, we run the task,
 * gathering any of its thrown exceptions to send to
 * afterExecute. We separately handle RuntimeException, Error
 * (both of which the specs guarantee that we trap) and arbitrary
 * Throwables.  Because we cannot rethrow Throwables within
 * Runnable.run, we wrap them within Errors on the way out (to the
 * thread&apos;s UncaughtExceptionHandler).  Any thrown exception also
 * conservatively causes thread to die.
 *
 * 5. After task.run completes, we call afterExecute, which may
 * also throw an exception, which will also cause thread to
 * die. According to JLS Sec 14.20, this exception is the one that
 * will be in effect even if task.run throws.
 *
 * The net effect of the exception mechanics is that afterExecute
 * and the thread&apos;s UncaughtExceptionHandler have as accurate
 * information as we can provide about any problems encountered by
 * user code.
 *
 * @param w the worker
 */
final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // allow interrupts
    boolean completedAbruptly = true;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // If pool is stopping, ensure thread is interrupted;
            // if not, ensure thread is not interrupted.  This
            // requires a recheck in second case to deal with
            // shutdownNow race while clearing interrupt
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;&amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                w.completedTasks++;
                w.unlock();
            }
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
</code></pre><p>~~</p>
<p>threadPoolExecutor执行图解：<br><img src="http://i2.itc.cn/20160630/aac_3fe63360_2218_b4e0_56d4_89a2c3216c58_2.png" alt="正常步骤"></p>
<ul>
<li>1.线程池判断核心线程</li>
</ul>
<p>通常会因为3过程会造成 锁和 线程创建和销毁额外开销，所以需要设置corePoolSize=MaxPoolSize.<br>执行如下：<br><img src="http://i3.itc.cn/20160630/aac_3fe63360_2218_b4e0_56d4_89a2c3216c58_1.png" alt="简化执行"></p>
<blockquote>
<p>相关使用场景(hystrix,心跳线程池切换，生产-消费者等)</p>
</blockquote>
<h3 id="ThreadPoolExecutor线程池配置"><a href="#ThreadPoolExecutor线程池配置" class="headerlink" title="ThreadPoolExecutor线程池配置"></a>ThreadPoolExecutor线程池配置</h3><blockquote>
<p>线程初始化/最大数(corePoolSize/MaxPoolSize)</p>
<p>线程活动保持时间/单位/名称(keepaliveTime/TimeUnit/ThreadFactory)</p>
<p>(runnableTaskQueue)</p>
<p>饱和策略(rejectExecutionHandler)</p>
</blockquote>
<h3 id="线程池任务提交-submit-execute-关闭-shutdown-shutdownNow"><a href="#线程池任务提交-submit-execute-关闭-shutdown-shutdownNow" class="headerlink" title="线程池任务提交 submit/execute | 关闭 shutdown/shutdownNow"></a>线程池任务提交 submit/execute | 关闭 shutdown/shutdownNow</h3><h3 id="合理配置线程池及JMX监控"><a href="#合理配置线程池及JMX监控" class="headerlink" title="合理配置线程池及JMX监控"></a>合理配置线程池及JMX监控</h3><blockquote>
<p>合理配置线程池</p>
</blockquote>
<pre><code>任务性质：CPU密集型任务，IO密集型任务和混合型任务(生产（io密集）-消费模型（cpu密集）)
任务优先级：高、中、低
任务执行时间：长、中、短
任务依赖性：是否依赖其他系统资源，例如数据库连接，接口调用等等
</code></pre><p>任务性质不同的任务可以用不同规模的线程池分开处理。<strong>CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池</strong>（dubbo配置线程数 ncpu+1）。<strong>IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu</strong>。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p>
<p><strong>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理</strong>。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</p>
<p><strong>执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行</strong>。</p>
<p><strong>依赖数据库连接池的任务</strong>，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越more长，那么线程数应该设置越大，这样才能更好的利用CPU。</p>
<blockquote>
<p>线程池监控(接口暴露或JMX暴露)</p>
</blockquote>
<p><img src="http://i1.itc.cn/20160630/aac_468c58c2_3765_9b1a_f179_e0e5297c4e6e_1.png" alt=""></p>
<h3 id="Executor线程池使用"><a href="#Executor线程池使用" class="headerlink" title="Executor线程池使用"></a>Executor线程池使用</h3><p><img src="http://i0.itc.cn/20160630/aac_a0b2b4a4_5abf_cf47_8617_a0ac18be5545_1.jpg" alt=""></p>
<blockquote>
<p>常用的几种线程池</p>
</blockquote>
<ol>
<li>newSingleThreadExecutor<br>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br>2.newFixedThreadPool<br>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>newCachedThreadPool<br>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，<br>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。<br>4.newScheduledThreadPool<br>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求</li>
</ol>
<blockquote>
<p>Callable和Future、FutureTask异步</p>
</blockquote>
<p>参考：<a href="http://ifeve.com/java-concurrency-tutorial-callable-future/" target="_blank" rel="external">http://ifeve.com/java-concurrency-tutorial-callable-future/</a></p>
<ul>
<li>问题</li>
</ul>
<p>1.Thread类和Runnable接口都不允许声明检查型异常，也不能定义返回值。</p>
<p>2.public void run()方法契约意味着你必须捕获并处理检查型异常。即使你小心地保存了异常信息（译者注：在捕获异常时）以便稍后检查，但也不能保证这个类（译者注：Runnable对象）的所有使用者都读取异常信息。</p>
<p>Callable接口和Future接口的引入以及他们对线程池的支持优雅地解决了这两个问题。</p>
<ul>
<li>Callable</li>
</ul>
<p>Callable接口定义了方法public T call() throws Exception。我们可以在Callable实现中声明强类型的返回值，甚至是抛出异常。尽管在Executors类中已经有一些方法可以将Runnable对象转换为Callable对象，你最好还是仔细复审现有的Runnable实现或Thread的子类。为什么还要这样做？主要是为了检查和清除因为Runnable无法抛出检查型异常而采用的变通方案。同时，你可能希望利用call()方法直接返回结果的能力，以省去读取值时的类型转换。<br>public static Callable<object> callable(Runnable task) {}</object></p>
<ul>
<li>Future</li>
</ul>
<p>当你提交一个Callable对象给线程池时，将得到一个Future对象，并且它和你传入的Callable有相同的结果类型声明。这个对象取代了Java 1.5之前直接操作具体Thread实例的做法。过去你不得不用Thread.join()或者Thread.join(long millis)等待任务完成，而现在你可以像下面的例子那样做.</p>
<ul>
<li>FutureTask</li>
</ul>
<p>~~</p>
<pre><code>/ * Possible state transitions:
 * NEW -&gt; COMPLETING -&gt; NORMAL
 * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL
 * NEW -&gt; CANCELLED
 * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED
 */
private volatile int state;
private static final int NEW          = 0;
private static final int COMPLETING   = 1;
private static final int NORMAL       = 2;
private static final int EXCEPTIONAL  = 3;
private static final int CANCELLED    = 4;
private static final int INTERRUPTING = 5;
private static final int INTERRUPTED  = 6;

/**
 * @throws CancellationException {@inheritDoc}
 */
public V get() throws InterruptedException, ExecutionException {
    int s = state;
    if (s &lt;= COMPLETING)
        s = awaitDone(false, 0L);
    return report(s);
}

/**
 * Awaits completion or aborts on interrupt or timeout.
 *
 * @param timed true if use timed waits
 * @param nanos time to wait, if timed
 * @return state upon completion
 */
private int awaitDone(boolean timed, long nanos)
    throws InterruptedException {
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    WaitNode q = null;
    boolean queued = false;
    for (;;) {
        if (Thread.interrupted()) {
            removeWaiter(q);
            throw new InterruptedException();
        }

        int s = state;
        if (s &gt; COMPLETING) {
            if (q != null)
                q.thread = null;
            return s;
        }
        else if (s == COMPLETING) // cannot time out yet
            Thread.yield();//交出时间片
        else if (q == null)
            q = new WaitNode();
        else if (!queued)
            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                 q.next = waiters, q);
        else if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos &lt;= 0L) {
                removeWaiter(q);
                return state;
            }
            LockSupport.parkNanos(this, nanos);
        }
        else
            LockSupport.park(this);
    }
}

public void run() {
    if (state != NEW ||
        !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                     null, Thread.currentThread()))
        return;
    try {
        Callable&lt;V&gt; c = callable;
        if (c != null &amp;&amp; state == NEW) {
            V result;
            boolean ran;
            try {
                result = c.call();//异步调用callable的call方法
                ran = true;
            } catch (Throwable ex) {
                result = null;
                ran = false;
                setException(ex);
            }
            if (ran)
                set(result);
        }
    } finally {
        // runner must be non-null until state is settled to
        // prevent concurrent calls to run()
        runner = null;
        // state must be re-read after nulling runner to prevent
        // leaked interrupts
        int s = state;
        if (s &gt;= INTERRUPTING)
            handlePossibleCancellationInterrupt(s);
    }
}
</code></pre><p>~~</p>
<p>//异步获取1-100之间的随机数</p>
<p>~~        </p>
<pre><code>//callable
Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() {

    @Override
    public Integer call() throws Exception {
        //取1-100之间随机数
        return new Random().nextInt(100);
    }
};

FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(callable);
new Thread(futureTask).start();

try {
    TimeUnit.SECONDS.sleep(5);

    Integer getNum = futureTask.get();
    System.out.println(&quot;getNum:&quot;+getNum);

} catch (InterruptedException e) {
    e.printStackTrace();
} catch (ExecutionException e) {
    e.printStackTrace();
}
</code></pre><p>~~</p>
<p>futureTask.get(); 执行步骤： 1.自选判断自己状态  2.执行FutureTask的 run方法</p>
<blockquote>
<p>JMX暴露线程池start/stop/restart操作</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><pre><code>并发相关知识:[并发概念](http://blog.jobbole.com/76308/)
juc博客：http://jolinzhangg.github.io/2016/06/22/juc/concurrentSyncFramework/
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jmm/" rel="tag">#jmm</a>
          
            <a href="/tags/lock/" rel="tag">#lock</a>
          
            <a href="/tags/juc/" rel="tag">#juc</a>
          
            <a href="/tags/线程池/" rel="tag">#线程池</a>
          
            <a href="/tags/阻塞队列/" rel="tag">#阻塞队列</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/06/01/(7.2).分布式架构-hystrix/" rel="next" title="hystrix线程池隔离">
                <i class="fa fa-chevron-left"></i> hystrix线程池隔离
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/02/(6.1).多线程-源码分析/" rel="prev" title="多线程源码分析">
                多线程源码分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/metor.ico"
               alt="Pedestrian" />
          <p class="site-author-name" itemprop="name">Pedestrian</p>
          <p class="site-description motion-element" itemprop="description">study for goal</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">36</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">50</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yanan0628" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://carlosfu.github.io/" target="_blank" title="fudada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  fudada
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://jolinzhangg.github.io/" target="_blank" title="xiaodada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  xiaodada
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#并发基本概念"><span class="nav-number">1.</span> <span class="nav-text">并发基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JMM内存模型"><span class="nav-number">1.1.</span> <span class="nav-text">JMM内存模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volitile-final-synchronized关键字"><span class="nav-number">1.2.</span> <span class="nav-text">volitile,final,synchronized关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程状态及流程"><span class="nav-number">2.</span> <span class="nav-text">线程状态及流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程流程图"><span class="nav-number">2.1.</span> <span class="nav-text">线程流程图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object监视器方法-和-condition接口"><span class="nav-number">2.2.</span> <span class="nav-text">object监视器方法 和 condition接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程应用实例"><span class="nav-number">2.3.</span> <span class="nav-text">线程应用实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#等待超时模式-像dubbo，rocketmq-hystrix架构会应用该模式"><span class="nav-number">2.3.1.</span> <span class="nav-text">等待超时模式(像dubbo，rocketmq,hystrix架构会应用该模式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#简单数据库连接池"><span class="nav-number">2.3.2.</span> <span class="nav-text">简单数据库连接池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程堆栈分析jstack-trace"><span class="nav-number">2.4.</span> <span class="nav-text">线程堆栈分析jstack trace</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jstack堆栈的状态信息"><span class="nav-number">2.4.1.</span> <span class="nav-text">jstack堆栈的状态信息</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS原子操作类"><span class="nav-number">3.</span> <span class="nav-text">CAS原子操作类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS同步框架"><span class="nav-number">4.</span> <span class="nav-text">AQS同步框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念混淆"><span class="nav-number">4.1.</span> <span class="nav-text">概念混淆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS需满足的三要素"><span class="nav-number">4.2.</span> <span class="nav-text">AQS需满足的三要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁"><span class="nav-number">4.3.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition"><span class="nav-number">4.4.</span> <span class="nav-text">condition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列同步器AbstractQueuedSynchronizer（AQS）"><span class="nav-number">4.5.</span> <span class="nav-text">队列同步器AbstractQueuedSynchronizer（AQS）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发容器和框架"><span class="nav-number">5.</span> <span class="nav-text">并发容器和框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞队列"><span class="nav-number">5.1.</span> <span class="nav-text">阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现原理"><span class="nav-number">5.2.</span> <span class="nav-text">实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdk中的7种阻塞队列"><span class="nav-number">5.3.</span> <span class="nav-text">jdk中的7种阻塞队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生产-消费者模型"><span class="nav-number">5.4.</span> <span class="nav-text">生产-消费者模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池分析"><span class="nav-number">6.</span> <span class="nav-text">线程池分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#流程及概念"><span class="nav-number">6.1.</span> <span class="nav-text">流程及概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadPoolExecutor线程池配置"><span class="nav-number">6.2.</span> <span class="nav-text">ThreadPoolExecutor线程池配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池任务提交-submit-execute-关闭-shutdown-shutdownNow"><span class="nav-number">6.3.</span> <span class="nav-text">线程池任务提交 submit/execute | 关闭 shutdown/shutdownNow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合理配置线程池及JMX监控"><span class="nav-number">6.4.</span> <span class="nav-text">合理配置线程池及JMX监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor线程池使用"><span class="nav-number">6.5.</span> <span class="nav-text">Executor线程池使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">7.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pedestrian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
