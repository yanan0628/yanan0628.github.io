<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="分布式搜索,近实时搜索," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="ElasticSearch初识介绍及特点介绍作为开源分布式搜索和数据处理平台，Elasticsearch不仅仅是一个数据库，同时它还是一个基于Lucene构建的开源、分布式、RESTful信息检索框架，能够实时搜索，并且稳定可靠，EIK架构为编程人员提供了一个分布式的可扩展的信息检索和基于Lucene的全文搜索，基于Logstash的日志处理机制、基于Kibana的挖掘结果可视化的的机制。 特点">
<meta name="keywords" content="分布式搜索,近实时搜索">
<meta property="og:type" content="article">
<meta property="og:title" content="elasticsearch">
<meta property="og:url" content="/2016/07/02/(7.4).分布式架构-elasticSearch/index.html">
<meta property="og:site_name" content="Meteor">
<meta property="og:description" content="ElasticSearch初识介绍及特点介绍作为开源分布式搜索和数据处理平台，Elasticsearch不仅仅是一个数据库，同时它还是一个基于Lucene构建的开源、分布式、RESTful信息检索框架，能够实时搜索，并且稳定可靠，EIK架构为编程人员提供了一个分布式的可扩展的信息检索和基于Lucene的全文搜索，基于Logstash的日志处理机制、基于Kibana的挖掘结果可视化的的机制。 特点">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://i1.itc.cn/20160825/aac_540444d4_baf0_549f_ca6b_c9e63308ca75_1.png">
<meta property="og:image" content="http://i3.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_5.png">
<meta property="og:image" content="http://i0.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_4.png">
<meta property="og:image" content="http://i3.itc.cn/20160825/aac_6527b376_6486_182e_c9e9_096d8163b67d_1.png">
<meta property="og:image" content="http://i2.itc.cn/20160825/aac_c36de6c2_193e_b59a_8332_6c7776d106c4_1.png">
<meta property="og:image" content="http://i0.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_3.png">
<meta property="og:image" content="http://i2.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_2.png">
<meta property="og:image" content="http://i1.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_1.png">
<meta property="og:image" content="http://i0.itc.cn/20160822/aac_e565d05b_1515_9665_2783_3397228cde23_3.png">
<meta property="og:image" content="http://i2.itc.cn/20160822/aac_5d8cc8be_6498_ec9e_1234_807d0f00ce71_1.png">
<meta property="og:image" content="http://i2.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_5.png">
<meta property="og:image" content="http://i0.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_1.png">
<meta property="og:image" content="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_6.png">
<meta property="og:image" content="http://i3.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_7.png">
<meta property="og:image" content="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_8.png">
<meta property="og:image" content="http://i3.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_4.png">
<meta property="og:image" content="http://i0.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_3.png">
<meta property="og:image" content="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_2.png">
<meta property="og:image" content="http://i3.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_1.png">
<meta property="og:image" content="http://i1.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_2.png">
<meta property="og:image" content="http://i1.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_3.png">
<meta property="og:image" content="http://i1.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_5.png">
<meta property="og:image" content="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_3.png">
<meta property="og:image" content="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_2.png">
<meta property="og:image" content="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_2.png">
<meta property="og:image" content="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_1.png">
<meta property="og:updated_time" content="2016-10-12T03:12:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="elasticsearch">
<meta name="twitter:description" content="ElasticSearch初识介绍及特点介绍作为开源分布式搜索和数据处理平台，Elasticsearch不仅仅是一个数据库，同时它还是一个基于Lucene构建的开源、分布式、RESTful信息检索框架，能够实时搜索，并且稳定可靠，EIK架构为编程人员提供了一个分布式的可扩展的信息检索和基于Lucene的全文搜索，基于Logstash的日志处理机制、基于Kibana的挖掘结果可视化的的机制。 特点">
<meta name="twitter:image" content="http://i1.itc.cn/20160825/aac_540444d4_baf0_549f_ca6b_c9e63308ca75_1.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> elasticsearch | Meteor </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Meteor</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="#" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                elasticsearch
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-02T10:52:03+08:00" content="2016-07-02">
              2016-07-02
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index">
                    <span itemprop="name">分布式</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/分布式/搜索引擎/" itemprop="url" rel="index">
                    <span itemprop="name">搜索引擎</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>
<h2 id="ElasticSearch初识"><a href="#ElasticSearch初识" class="headerlink" title="ElasticSearch初识"></a>ElasticSearch初识</h2><h3 id="介绍及特点"><a href="#介绍及特点" class="headerlink" title="介绍及特点"></a>介绍及特点</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>作为开源分布式搜索和数据处理平台，Elasticsearch不仅仅是一个数据库，同时它还是一个基于Lucene构建的开源、分布式、RESTful信息检索框架，能够实时搜索，并且稳定可靠，EIK架构为编程人员提供了一个分布式的可扩展的信息检索和基于Lucene的全文搜索，基于Logstash的日志处理机制、基于Kibana的挖掘结果可视化的的机制。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>分布式实时文件存储</li>
<li>实时分析的分布式搜索引擎</li>
<li>可以扩展到上百台服务器</li>
</ul>
<h4 id="elasticSearch整体架构："><a href="#elasticSearch整体架构：" class="headerlink" title="elasticSearch整体架构："></a>elasticSearch整体架构：</h4><p><img src="http://i1.itc.cn/20160825/aac_540444d4_baf0_549f_ca6b_c9e63308ca75_1.png" alt=""></p>
<!-- more -->
<h4 id="与Lucene的区别？"><a href="#与Lucene的区别？" class="headerlink" title="与Lucene的区别？"></a>与Lucene的区别？</h4><p>Elasticsearch执行搜索的速度更快，可以简单的通过HTTP方式，使用JSON来操作数据，并支持对分布式集群的搜索。<br>Elasticsearch对分布式支持，其索引功能分拆为多个分片，每个分片可有0个或多个副本，集群中的每个数据节点都可承载一个或多个分片，并且能协调和处理各种操作；负载再平衡（Rebalancing）和路由（Routing）在大多数情况下都是自动完成的。</p>
<h3 id="安装及目录"><a href="#安装及目录" class="headerlink" title="安装及目录"></a>安装及目录</h3><blockquote>
<p>安装</p>
</blockquote>
<p><a href="http://www.shaheng.me/blog/2015/06/elasticsearch--.html" target="_blank" rel="external">http://www.shaheng.me/blog/2015/06/elasticsearch--.html</a></p>
<p><a href="http://10.16.51.33:9200/_plugin/head/" target="_blank" rel="external">http://10.16.51.33:9200/_plugin/head/</a></p>
<p>测试路由：<a href="http://10.16.51.33:9200/_plugin/paramedic/index.html" target="_blank" rel="external">http://10.16.51.33:9200/_plugin/paramedic/index.html</a></p>
<blockquote>
<p>源码编译</p>
</blockquote>
<p>jdk1.8/gradle2.8以上版本</p>
<p>gradle compileJava</p>
<blockquote>
<p>data索引目录</p>
</blockquote>
<p><strong>data目录结构：</strong><br><img src="http://i3.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_5.png" alt=""></p>
<pre><code>node.lock    是用来确保一个data目录只被唯一的elasticsearch应用使用。
global_0.st    是个二进制文件，该文件包含了集群的元数据。比如一些persistent持久的修改。
            0表示元数据的版本。
</code></pre><p><strong>index索引目录:</strong><br><img src="http://i0.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_4.png" alt=""></p>
<pre><code>0            表示索引indice2在该节点上的1号分片。
state-23    表示的是索引_state的状态信息，23表示的是版本。这个文件中包含了索引的元数据，                如索引的创建时间，索引的设置和mapping。
state-31    表示的是分片的状态，比如该分片是否是主分片。
</code></pre><h3 id="lucene相关概念"><a href="#lucene相关概念" class="headerlink" title="lucene相关概念"></a>lucene相关概念</h3><blockquote>
<p>index和search过程的流程图</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160825/aac_6527b376_6486_182e_c9e9_096d8163b67d_1.png" alt=""></p>
<pre><code>Lucene的analysis模块主要负责词法分析及语言处理而形成Term。
Lucene的index模块主要负责索引的创建，里面有IndexWriter。
Lucene的store模块主要负责索引的读写。
Lucene的QueryParser主要负责语法分析。
Lucene的search模块主要负责对索引的搜索。
Lucene的similarity模块主要负责对相关性打分的实现。
</code></pre><blockquote>
<p>相关概念</p>
</blockquote>
<p>lucene 存储的层次结构</p>
<p><img src="http://i2.itc.cn/20160825/aac_c36de6c2_193e_b59a_8332_6c7776d106c4_1.png" alt=""></p>
<ul>
<li><p>索引(Index)：在Lucene中一个索引是放在一个文件夹中的。</p>
</li>
<li><p>段(Segment)：一个索引可以包含多个段，段与段之间是独立的，添加新文档可以生成新的段，不同的段可以合并。具有相同前缀文件的属同一个段，图中共两个段 “_0” 和 “_1”。<br>segments.gen和segments_5是段的元数据文件，也即它们保存了段的属性信息。</p>
<p>  可参考es： <a href="http://*.*.*.*:9200/kis-index-v1/_segments">http://*.*.*.*:9200/kis-index-v1/_segments</a> 段信息</p>
</li>
<li><p>文档(Document)：<br>文档是我们建索引的基本单位，不同的文档是保存在不同的段中的，一个段可以包含多篇文档。<br>新添加的文档是单独保存在一个新生成的段中，随着段的合并，不同的文档合并到同一个段中。</p>
</li>
<li><p>域(Field)：一篇文档包含不同类型的信息，可以分开索引，比如标题，时间，正文，作者等，都可以保存在不同的域里。<br>不同域的索引方式可以不同，在真正解析域的存储的时候，我们会详细解读。</p>
</li>
<li><p>词(Term)：<br>词是索引的最小单位，是经过词法分析和语言处理后的字符串。</p>
</li>
</ul>
<p>Lucene的索引结构中，即保存了正向信息，也保存了反向信息。</p>
<blockquote>
<p>elasticsearch保存的部分索引文件格式：</p>
</blockquote>
<p><img src="http://i0.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_3.png" alt="索引文件部分格式"></p>
<p><strong>所谓正向信息：</strong></p>
<p>按层次保存了从索引，一直到词的包含关系：<br>索引(Index) –&gt; 段(segment) (segments.gen, segments_N) -&gt; 文档(Document)–&gt; 域(Field)(fnm, fdx, fdt) –&gt; 词(Term) (tvx, tvd, tvf)<br>也即此索引包含了那些段，每个段包含了那些文档，每个文档包含了那些域，每个域包含了那些词。</p>
<p>如上图，包含正向信息的文件有：</p>
<pre><code>segments_N  保存了此索引包含多少个段，每个段包含多少篇文档。
.fnm后缀文件 保存了此段包含了多少个域，每个域的名称及索引方式。
.fdx .fdt后缀文件保存了此段包含的所有文档，每篇文档包含了多少域，每个域保存了那些信息。
.tvx，.tvd，.tvf后缀文件 保存了此段包含多少文档，每篇文档包含了多少域，每个域包含了多少词，每个词的字符串，位置等信息。
</code></pre><p><strong>所谓反向信息：</strong></p>
<p>保存了词典到倒排表的映射：词(Term) –&gt; 文档(Document)</p>
<p>如上图，包含反向信息的文件有：</p>
<pre><code>XXX.tis，XXX.tii保存了词典(Term Dictionary)，也即此段包含的所有的词按字典顺序的排序。
XXX.frq保存了倒排表，也即包含每个词的文档ID列表。
XXX.prx保存了倒排表中每个词在包含此词的文档中的位置。
</code></pre><h3 id="elasticsearch-相关概念"><a href="#elasticsearch-相关概念" class="headerlink" title="elasticsearch 相关概念"></a>elasticsearch 相关概念</h3><p>1).<strong>Cluster和Node</strong>——Elasticsearch中的Cluster是对外提供搜索服务的集群，组成这个集群的各个节点叫Node.集群Cluster是一组有着相同cluster.name的节点，他们协同工作，互相分享数据，提供了故障转移和扩展的功能。Node又分为IndexNode、DataNode等。节点之间是对等关系的(去中心化)，而弱化的Master节点只不过多了维护集群状态的功能。</p>
<p>(2).<strong>Shards</strong>——Elasticsearch将一个完整的索引分成若干个部分，每个部分就是一个Shards，每个Shard实际上就是一个基于Lucene的索引。Shards的数量一般在索引创建前制定，且索引创建后不能更改。</p>
<p>(3).<strong>Replicas</strong>——Replics是索引的冗余备份，可用于防止数据丢失或用来做负载均衡。一般地，Elasticsearch会自动对索引请求进行负载均衡。</p>
<p>(4).<strong>Recover</strong>——在有节点加入或退出集群Cluster或故障节点重新启动时，Elasticsearch会根据机器的负载情况，对索引分片Shards进行重新分配。</p>
<p>(5).<strong>River</strong>——River是一个运行在Elasticsearch集群内部的插件，主要用来从外部获取以后数据，然后在Elasticsearch里创建索引。常见的有MongoDB、JDBC river Plugin等。</p>
<p>(6).<strong>Gateway</strong>——是Elasticsearch索引数据快照的存储方式，当Elasticsearch集群关闭再重新启动时，就会从Gateway中读取索引数据快照。Elasticsearch支持多种类型的Gateway,本地文件系统、分布式文件系统、Hadoop的HDFS</p>
<p>(7).<strong>Discover.zen</strong>——Discover.zen代表Elasticsearch的自动发现节点机制。Zen用来实现节点自动发现和Master节点选举，Master节点负责节点的加入和退出以及分片shard的重新分配。</p>
<p>(8).<strong>Transport</strong>——Transport代表Elasticsearch内部节点或集群与客户端的交互方式，默认内部是使用TCP协议进行交互的，同时支持HTTP协议(JSON格式)、Thrift、Servlet等传输协议。</p>
<p>(9)<strong>Index、Type、Document、Field</strong>——Index是数据存储的地方，可以快速高效的堆索引中的数据进行全文索引，类似于RDBMS数据库中的Database;在Index下一般会有多个存储数据的Type,Type类似于Database的table,用来存放具体数据；Document类似于关系数据库的一行数据，在一个Type里的每一个Document都有一个唯一的ID作为区分。</p>
<p>(10)<strong>Mapping</strong>——Mapping定义索引下的Type的字段处理规则，如索引如何建立、索引数据类型、是否保存原始索引JSON文档，是否需要进行分词处理、如何进行分词处理等。一般地，一个索引文件下能存储不同映像(Mapping)的类型文件(Types).</p>
<p>RESTful接口URL的格式：</p>
<pre><code>curl -X&lt;VERB&gt; &apos;&lt;PROTOCOL&gt;://&lt;HOST&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&apos; -d &apos;&lt;BODY&gt;&apos;

VERB HTTP方法：GET(获取), POST(更新), PUT(创建), HEAD, DELETE(删除)
PROTOCOL： http或者https协议（只有在Elasticsearch前面有https代理的时候可用）
HOST： Elasticsearch集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫localhost
PORT： Elasticsearch HTTP服务所在的端口，默认为9200
QUERY_STRING： 一些可选的查询请求参数，例如?pretty参数将使请求返回更加美观易读的JSON数据
BODY： 一个JSON格式的请求主体（如果请求需要的话）
</code></pre><h2 id="ElasticSearch存储结构"><a href="#ElasticSearch存储结构" class="headerlink" title="ElasticSearch存储结构"></a>ElasticSearch存储结构</h2><h3 id="lucene文件存储格式"><a href="#lucene文件存储格式" class="headerlink" title="lucene文件存储格式"></a>lucene文件存储格式</h3><p><img src="http://i2.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_2.png" alt=""><br><img src="http://i1.itc.cn/20160822/aac_7f64ca29_4b17_68b4_d7eb_26de44fe8832_1.png" alt=""></p>
<p><strong>fdx和fdt的结构:</strong></p>
<p>对于每一个域，fieldnum是域号，接着是一个8位的byte，最低一位表示此域是否分词(tokenized)，倒数第二位表示此域是保存字符串数据还是二进制数据，倒数第三位表示此域是否被压缩，再接下来就是存储域的值。</p>
<p>类似 B+树的数据结构：<br><img src="http://i0.itc.cn/20160822/aac_e565d05b_1515_9665_2783_3397228cde23_3.png" alt=""></p>
<p>文件存储大小：<br><img src="http://i2.itc.cn/20160822/aac_5d8cc8be_6498_ec9e_1234_807d0f00ce71_1.png" alt=""></p>
<h3 id="ElasticSearch存储模块"><a href="#ElasticSearch存储模块" class="headerlink" title="ElasticSearch存储模块"></a>ElasticSearch存储模块</h3><ul>
<li><p>simple fs(简单文件系统存储)：对应Lucene中的SimpleFsDirectory。 这种实现的并发性能较差，<strong>多线程会出现瓶颈</strong>。当索引需要持久化最好使用niofs。【windows 32位系统默认使用存储类型】</p>
</li>
<li><p>nio fs(新I/O文件系统存储)：对应Lucene中的NIOFSDirectory。这种方式可以<strong>多个线程在不降低性能的前提下并发地读同一个文件</strong>。【除开simple fs和mmmapfs以外  默认使用存储类型】</p>
</li>
<li><p>mmapfs：它使用mmap系统命令来读取和随机写入文件，并从进程的虚拟地址空间的可用部分中分出与被映射文件大小相同的空间没用于装载被映射文件。它<strong>没有任何锁机制，适合多线程访问，当时有mmap来读取索引时 他就像已经缓存过(映射到虚拟地址空间)，当从lucene索引读取某文件时，不需要把文件载入操作系统缓存中，因此获得了更快的访问速度。这基本上允许lucene和elasticsearch去直接访问I/O缓存，从而获得更快的索引文件访问速度。 一般来说，如果运行的是64位操作系统，你应该选择mmapfs。如果没有运行64位操作系统，为UNIX系统选择niofs，为Windows系统选择simplefs。</strong>【Solaris和windows 64位系统使用存储类型】</p>
</li>
<li><p>memory：对应Lucene中的RamIndexStore，它允许我们把全部索引存放在内存中，因此文件没有存储在硬盘上。这意味着 索引数据是非持久化的，只要集群重启 数据就会被丢失。</p>
</li>
</ul>
<blockquote>
<p>配置</p>
</blockquote>
<pre><code>设置存储类型 index.store.type:

线上es配置：
index.translog.flush_threshold_period: 600s
index.refresh_interval: 10s
indices.memory.index_buffer_size: 30%
indices.memory.min_index_buffer_size: 500m
index.translog.flush_threshold: 50000
index.store.type: mmapfs
index.merge.policy.use_compound_file: false
index.cache.field.type: soft
</code></pre><h3 id="store-level-throttling"><a href="#store-level-throttling" class="headerlink" title="store level throttling"></a>store level throttling</h3><p>Elasticsearch中的segments merge采用异步的方式，但系统低IO的情况下还是会影响索引和查询操作。想要解决这种问题，Elasticsearch提供两种方式（索引级别和节点 级别）的配置。</p>
<pre><code>节点级别配置：
    indices.store.throttle.type：merge
    indices.store.throttle.max_bytes_per_sec：5mb //默认20mb 如上设置之后，该节点上的segments merge不会超过5mb/s
索引级别设置：
    index.store.throttle.type：node
    index.store.throttle.max_bytes_per_sec：10mb
</code></pre><h3 id="段合并策略"><a href="#段合并策略" class="headerlink" title="段合并策略"></a>段合并策略</h3><p>段合并直接影响到系统的性能，需要进行大量的IO操作。段合并策略如下：</p>
<ul>
<li>tiered(默认)</li>
</ul>
<p>ElasticSearch默认合并策略，它能合并大小相似的索引段，并考虑每层允许的索引段的最大个数。</p>
<ul>
<li>log_byte_size</li>
</ul>
<p>按字节数 进行合并</p>
<ul>
<li>log_doc</li>
</ul>
<p>按段里存储doc进行合并</p>
<ul>
<li><p>参数配置</p>
<pre><code>index.merge.policy.type:tiered
</code></pre></li>
</ul>
<blockquote>
<p>segment结构</p>
</blockquote>
<p><img src="http://i2.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_5.png" alt=""><br><img src="http://i0.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_1.png" alt=""><br><img src="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_6.png" alt=""><br><img src="http://i3.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_7.png" alt=""><br><img src="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_8.png" alt=""></p>
<blockquote>
<p>合并过程</p>
</blockquote>
<ul>
<li>提交过程</li>
</ul>
<p><img src="http://i3.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_4.png" alt=""></p>
<ul>
<li>数据落地的步骤</li>
</ul>
<p><img src="http://i0.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_3.png" alt=""></p>
<ul>
<li>segment合并的过程:</li>
</ul>
<p><img src="http://i1.itc.cn/20160825/aac_82ddb3fc_de8e_67c7_9a85_19b3df5f55e7_2.png" alt=""></p>
<h3 id="准实时、更新、提交及事务日志"><a href="#准实时、更新、提交及事务日志" class="headerlink" title="准实时、更新、提交及事务日志"></a>准实时、更新、提交及事务日志</h3><p>一个好的搜索引擎需要保证在新索引建立后 数据如何能够立即检索到，</p>
<blockquote>
<p>准实时-版本_version</p>
</blockquote>
<pre><code>每次新建索引 会产生一个新的文档，_version+1，标记旧文档为删除并添加了一个完整的新文
档,旧版本文档不会立即消失，但你也不能去访问它。Elasticsearch会在你继续索引更多数据时
清理被删除的文档。如果新的未建成功，访问仍然是旧的文档内容。
</code></pre><p><img src="http://i3.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_1.png" alt=""> </p>
<blockquote>
<p>索引更新/提交涉及段的合并</p>
</blockquote>
<p>事实上Elasticsearch遵循与之前所说完全相同的过程，这个过程如下：</p>
<ul>
<li>从旧文档中检索JSON</li>
<li>修改它</li>
<li>删除旧文档</li>
<li>索引新文档</li>
</ul>
<p>唯一的不同是update API完成这一过程只需要一个客户端请求既可，不再需要get和index请求了.    </p>
<pre><code>_refresh索引刷新:

    设置参数  &quot;refresh_interval&quot;:&quot;10s/m/h(时间单位)&quot;
    curl -XGET &apos;http://10.16.51.33:9200/data-test/_refresh&apos;
</code></pre><blockquote>
<p>事务日志刷新</p>
</blockquote>
<pre><code>_flush日志刷新：

    设置参数 
    curl -XGET &apos;http://10.16.51.33:9200/data-test/_flush&apos;
    {&quot;_shards&quot;:{&quot;total&quot;:10,&quot;successful&quot;:10,&quot;failed&quot;:0}}
</code></pre><p>查看数据分片情况：<br><img src="http://i1.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_2.png" alt=""><br>执行flush之后<br><img src="http://i1.itc.cn/20160825/aac_ff5c6654_3690_2fab_bb7b_439b305b5141_3.png" alt=""></p>
<h2 id="ElasticSearch分布式集群"><a href="#ElasticSearch分布式集群" class="headerlink" title="ElasticSearch分布式集群"></a>ElasticSearch分布式集群</h2><p>es官方文档讲解cluster：<br><a href="https://www.elastic.co/guide/en/elasticsearch/guide/current/distributed-cluster.html" target="_blank" rel="external">https://www.elastic.co/guide/en/elasticsearch/guide/current/distributed-cluster.html</a></p>
<p>集群健康：<a href="http://10.16.51.33:9200/_cluster/health" target="_blank" rel="external">http://10.16.51.33:9200/_cluster/health</a></p>
<h3 id="通信机制-发现模块"><a href="#通信机制-发现模块" class="headerlink" title="通信机制-发现模块"></a>通信机制-发现模块</h3><p>该模块主要负责集群中节点的自动发现和Master节点的选举。节点之间使用p2p的方式进行直接通信，不存在单点故障的问题。Elasticsearch中，Master节点维护集群的全局状态，比如节点加入和离开时进行shard的重新分配。通过发现机制(discovery mechanism)极大简化了 集群工作，只需要定义了相同的cluster.name的节点会自动组成集群，需要在同一个网段。</p>
<ul>
<li><p>zen discovery elasticSearch默认实现 多播/单播</p>
<p>  <strong>Master选举</strong>：设置最小主节点候选节点数应设置 集群节点数一半+1，通过参数 discovery.zen.minimum_master_nodes配置当前集群中最少的主节点数。</p>
<p>  <strong>Zen错误发现</strong>：一般存在两个故障检测过程。</p>
<pre><code>第一个是主节点周期性的ping其他节点。
第二就是其他节点周期的ping主节点。
</code></pre><p>  ping_interval：1s节点被ping的频率<br>  ping_timeout：30s等待ping返回的时间<br>  ping_timeout：3重试次数，超过该次，就认为该节点不可用  </p>
<p>  参数配置</p>
<p>  多播：<br>  discovery.zen.ping.multicast.group: 代表发送多播消息地址，默认 224.2.2.4<br>  discovery.zen.ping.multicast.port： 通讯端口，默认值：54328<br>  discovery.zen.ping.multicast.ttl:   定义多播消息的生存期，默认是3<br>  discovery.zen.ping.multicast.address:通讯接口，可赋值地址或接口，默认值：所有接口<br>  discovery.zen.ping.multicast.enabled: 多播自动发现禁用开关 默认值：true</p>
<p>  单播：<br>  discovery.zen.ping.unicast.hosts:host1：port1，host2,：port2  </p>
</li>
<li><p>Azure discovery 插件方式，多播</p>
</li>
<li>EC2 discovery 插件方式，多播</li>
<li>Google Compute Engine (GCE)discovery 插件方式多播</li>
</ul>
<h3 id="故障转移-failover"><a href="#故障转移-failover" class="headerlink" title="故障转移 failover"></a>故障转移 failover</h3><p>数据迁移规则？ 主节点 竞选规则    裁决者</p>
<h3 id="水平-垂直扩容-scale-Horizontally"><a href="#水平-垂直扩容-scale-Horizontally" class="headerlink" title="水平/垂直扩容 scale Horizontally"></a>水平/垂直扩容 scale Horizontally</h3><h3 id="ElasticSearch工作流程"><a href="#ElasticSearch工作流程" class="headerlink" title="ElasticSearch工作流程"></a>ElasticSearch工作流程</h3><blockquote>
<p>创建、索引和删除文档</p>
</blockquote>
<p><img src="http://i1.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_5.png" alt=""></p>
<pre><code>该过程分为以下3步：
1.客户端发送一个创建、检索或删除文档的请求到节点1。
2.节点使用文档的_id（默认情况下，即不指定路由）判断该文档属于分片0。转发请求到主分片0所在的节点3上。
3.节点3在主分片上执行请求。如果成功，则并行的发送请求到0分片的副本分片所在的节点1和节点2上。当所有的副本分片执行成功后，节点3向请求节点报告操作成功，最后请求节点向客户端报告成功。

可以通过修改可选请求参数去修改上述过程。
replication：（默认sync）
    sync：主分片会等待从分片执行成功，然后返回给客户端。
    async：当主分片执行成功则返回给客户端。
    With async replication, it is possible to overload Elasticsearch by sending too many requests without waiting for their completion.

consistency和timeout：
quorum（法定人数）=int( (primary + number_of_replicas) / 2 ) + 1 
只有当活跃的节点数&gt;=quorum时，对索引的创建，索引和删除才会成功。否则等待timeout时长，默认为1分钟，如果期间节点恢复运行，则可以执行索引的创建，索引和删除。否则失败。但是对索引的查询没有影响。
但是当number_of_replicas=1的时候，则无上述限制，即使只有一个节点的时候，也可以进行索引的创建，索引和删除操作。
</code></pre><blockquote>
<p>检索文档</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_3.png" alt=""></p>
<pre><code>该过程分为以下3个部分：
1.客户端发送请求到节点1
2.节点使用_id判断文档属于分片0，分片0存在于这3个节点上。在这个例子中该请求会转发到节点2上。
3.节点2返回文档到节点1，然后节点1再将文档返回客户端。
注：在第二步中之所以要将请求转发到节点2，是为了负载均衡，当节点收到检索命令的时候，elasticsearch会轮询文档所在的分片。
</code></pre><blockquote>
<p>更新文档</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_2.png" alt=""></p>
<pre><code>该过程分为以下4个部分：
1.客户端发送请求到节点1。
2.转发请求到文档所在的主节点3上。
3.节点3从主分片中检索到文档，然后改变文档_source的json数据，尝试重新索引到主分片，如果在这个过程中该文档已经被其他的进程修改了，那么会重复步骤3，如果经过retry_on_conflict 次尝试还是失败，则放弃更新。
4.如果节点3成功的更新了文档，它会将新的文档并行的发送到副本分片所在的节点1和2上。当所有的副本分片都成功的创建了文档时，节点3会通知请求节点更新成功，请求节点再通知客户端更新成功。
注：当主分片转发变更到它的副本分片的时候，它不会发送更新请求，而是发送新版本的文档。
</code></pre><blockquote>
<p>mget操作</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_2.png" alt=""></p>
<pre><code>该过程分为以下两步：
1.客户端发送mget请求到节点1。
2.节点1为每个分片建立一个multi-get请求，并行的发送这些请求到分片所在的主节点或从节点上。当所有分片的响应被返回到节点1时，节点1会建立响应并发送回客户端。
</code></pre><blockquote>
<p>bulk操作</p>
</blockquote>
<p><img src="http://i3.itc.cn/20160824/aac_058a4586_c0ec_cfc4_ffba_eb1a858f787e_1.png" alt=""></p>
<pre><code>该过程步骤如下：
1.客户端发送bulk请求到节点1。
2.节点1为每个主分片建立一个bulk请求，并行的发送这些请求到主分片所在的节点上。
3.主节点顺序的执行每个action，当每一个action成功后，主分片会并行的发送新的文档到副本分片上，然后主分片继续下一个action，当所有副本分片对于所有action的命令都成功时，会向请求节点报告成功，然后请求节点会整理这些响应，并返回到客户端。
注：这个bulk请求需要被读入到内存中，所以越大的请求意味着能被其他请求使用的内存越小。一般来说，bulk请求包含1000-5000个文档，如果文档越大则bulk包含的文档越少。一个好的bulk的size应该在5-15MB左右。
</code></pre><blockquote>
<p>msearch操作/sort排序</p>
</blockquote>
<h3 id="路由模块"><a href="#路由模块" class="headerlink" title="路由模块"></a>路由模块</h3><p>索引别名相当于快捷方式或软链接，可以指向一个或多个索引，甚至可以指向带路由的分片。</p>
<p>指定路由 ：</p>
<p>查询路由：</p>
<p>curl -XGET ‘<a href="http://10.16.51.33:9200/kis-index-v1/kisstar/_search?query=starName:ladygaga&amp;routing=2&amp;explain&amp;pretty" target="_blank" rel="external">http://10.16.51.33:9200/kis-index-v1/kisstar/_search?query=starName:ladygaga&amp;routing=2&amp;explain&amp;pretty</a>‘</p>
<ul>
<li><p>应用实例</p>
<p>  1.将某一聚类数据 特意放在某一分片，提高检索效率</p>
<pre><code>1.1 将用户的数据集放到一个分片
1.2 将专辑下的视频放到一个分片
</code></pre></li>
</ul>
<h3 id="索引别名模块"><a href="#索引别名模块" class="headerlink" title="索引别名模块"></a>索引别名模块</h3><p>Elasticsearch的API支持给索引起别名，有了别名之后可以像使用索引一样使用它。但不只是这些，一个别名可以映射多个索引，所以在需要经常指定多个索引查询的情况下，大可将所查询的索引起一个别名来查。别名也可以将索引查询的过滤条件包含在内，使用别名查询时可以查询索引的一个子集。</p>
<ul>
<li><p>创建一个别名：</p>
<p>  curl -XPOST ‘<a href="http://localhost:9200/_aliases&#39;-d" target="_blank" rel="external">http://localhost:9200/_aliases&#39;-d</a> ‘<br>  {  </p>
<pre><code>&quot;actions&quot; : [  
    { &quot;add&quot; : { &quot;index&quot; : &quot;test1&quot;,&quot;alias&quot; : &quot;alias1&quot; } }  
]  
</code></pre><p>  }’  </p>
</li>
<li><p>删除别名：</p>
<p>  curl -XPOST ‘<a href="http://localhost:9200/_aliases&#39;-d" target="_blank" rel="external">http://localhost:9200/_aliases&#39;-d</a> ‘<br>  {  </p>
<pre><code>&quot;actions&quot; : [  
    { &quot;remove&quot; : { &quot;index&quot; : &quot;test1&quot;,&quot;alias&quot; : &quot;alias1&quot; } }  
]  
</code></pre><p>  }’ </p>
</li>
</ul>
<h2 id="ElasticSearch原理使用"><a href="#ElasticSearch原理使用" class="headerlink" title="ElasticSearch原理使用"></a>ElasticSearch原理使用</h2><h3 id="文档存储及映射规则"><a href="#文档存储及映射规则" class="headerlink" title="文档存储及映射规则"></a>文档存储及映射规则</h3><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>java主类位于org.elasticsearch.bootstrap。主要逻辑是生成了一个InternalNode节点，并且启动了一个keepalive线程。结点的启动代表整个es进程启动了。</p>
<p>Bootstarp启动线程 Node Keepalive</p>
<p>client  TransportClient</p>
<p>~~<br>public enum SearchType {<br>        /**</p>
<pre><code> * Same as {@link #QUERY_THEN_FETCH}, except for an initial scatter phase which goes and computes the distributed
 * term frequencies for more accurate scoring.
 */
DFS_QUERY_THEN_FETCH((byte) 0),
/**
 * The query is executed against all shards, but only enough information is returned (not the document content).
 * The results are then sorted and ranked, and based on it, only the relevant shards are asked for the actual
 * document content. The return number of hits is exactly as specified in size, since they are the only ones that
 * are fetched. This is very handy when the index has a lot of shards (not replicas, shard id groups).
 */
QUERY_THEN_FETCH((byte) 1),
/**
 * Same as {@link #QUERY_AND_FETCH}, except for an initial scatter phase which goes and computes the distributed
 * term frequencies for more accurate scoring.
 */
DFS_QUERY_AND_FETCH((byte) 2),
/**
 * The most naive (and possibly fastest) implementation is to simply execute the query on all relevant shards
 * and return the results. Each shard returns size results. Since each shard already returns size hits, this
 * type actually returns size times number of shards results back to the caller.
 */
QUERY_AND_FETCH((byte) 3),
/**
 * Performs scanning of the results which executes the search without any sorting.
 * It will automatically start scrolling the result set.
 */
SCAN((byte) 4),
/**
 * Only counts the results, will still execute facets and the like.
 */
COUNT((byte) 5);

/**
 * The default search type ({@link #QUERY_THEN_FETCH}.
 */
public static final SearchType DEFAULT = QUERY_THEN_FETCH;
</code></pre><ul>
<li>query and fetch</li>
</ul>
<p>向索引的所有分片（shard）都发出查询请求，各分片返回的时候把元素文档（document）和计算后的排名信息一起返回。这种搜索方式是最快的。因为相比下面的几种搜索方式，这种查询方法只需要去shard查询一次。但是各个shard返回的结果的数量之和可能是用户要求的size的n倍。</p>
<ul>
<li>query then fetch（默认的搜索方式）</li>
</ul>
<p>如果你搜索时，没有指定搜索方式，就是使用的这种搜索方式。这种搜索方式，大概分两个步骤，第一步，先向所有的shard发出请求，各分片只返回排序和排名相关的信息（注意，不包括文档document)，然后按照各分片返回的分数进行重新排序和排名，取前size个文档。然后进行第二步，去相关的shard取document。这种方式返回的document与用户要求的size是相等的。</p>
<ul>
<li>DFS query and fetch</li>
</ul>
<p>这种方式比第一种方式多了一个初始化散发(initial scatter)步骤，有这一步，据说可以更精确控制搜索打分和排名。</p>
<ul>
<li>DFS query then fetch</li>
</ul>
<p>比第2种方式多了一个初始化散发(initial scatter)步骤。</p>
<h3 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h3><blockquote>
<p>文档存储机制</p>
<p>文档CRUD</p>
</blockquote>
<p>PUT/POST/GET/DELETE </p>
<ul>
<li><p>Manually (aka do it yourself) using native byte[] or as a String</p>
<pre><code>String json = &quot;{&quot; +
    &quot;\&quot;user\&quot;:\&quot;kimchy\&quot;,&quot; +
    &quot;\&quot;postDate\&quot;:\&quot;2013-01-30\&quot;,&quot; +
    &quot;\&quot;message\&quot;:\&quot;trying out Elasticsearch\&quot;&quot; +
&quot;}&quot;;
</code></pre></li>
<li><p>Using a Map that will be automatically converted to its JSON equivalent</p>
<pre><code>Map&lt;String, Object&gt; json = new HashMap&lt;String, Object&gt;();
json.put(&quot;user&quot;,&quot;kimchy&quot;);
json.put(&quot;postDate&quot;,new Date());
json.put(&quot;message&quot;,&quot;trying out Elasticsearch&quot;);
</code></pre></li>
<li><p>Using a third party library to serialize your beans such as Jackson</p>
<pre><code>// instance a json mapper
ObjectMapper mapper = new ObjectMapper(); // create once, reuse

// generate json
byte[] json = mapper.writeValueAsBytes(yourbeaninstance);
</code></pre></li>
<li><p>Using built-in helpers XContentFactory.jsonBuilder()</p>
<pre><code>XContentBuilder builder = jsonBuilder()
.startObject()
    .field(&quot;user&quot;, &quot;kimchy&quot;)
    .field(&quot;postDate&quot;, new Date())
    .field(&quot;message&quot;, &quot;trying out Elasticsearch&quot;)
.endObject();
String json = builder.string();
</code></pre></li>
</ul>
<blockquote>
<p>批量机制 mget bulk msearch </p>
<p>排序规则</p>
</blockquote>
<h2 id="ElasticSearch客户端使用"><a href="#ElasticSearch客户端使用" class="headerlink" title="ElasticSearch客户端使用"></a>ElasticSearch客户端使用</h2><h3 id="maven依赖"><a href="#maven依赖" class="headerlink" title="maven依赖"></a>maven依赖</h3><p>maven中央仓库：<a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.elasticsearch%22%20AND%20a%3A%22elasticsearch%22" target="_blank" rel="external">http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.elasticsearch%22%20AND%20a%3A%22elasticsearch%22</a></p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.elasticsearch&lt;/groupId&gt;
    &lt;artifactId&gt;elasticsearch&lt;/artifactId&gt;
    &lt;version&gt;${es.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><h3 id="客户端TransportClient实例化"><a href="#客户端TransportClient实例化" class="headerlink" title="客户端TransportClient实例化"></a>客户端TransportClient实例化</h3><p>Obtaining an elasticsearch Client is simple. The most common way to get a client is by creating a TransportClient that connects to a cluster.</p>
<blockquote>
<p>获取es的client</p>
</blockquote>
<pre><code>// on startup
Client client = TransportClient.builder().build()
        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host1&quot;), 9300))
        .addTransportAddress(new InetSocketTransportAddress(InetAddress.getByName(&quot;host2&quot;), 9300));

// on shutdown
client.close();

// 设置es的别名，否则名称命名为&quot;elasticsearch&quot;
Settings settings = Settings.settingsBuilder()
    .put(&quot;cluster.name&quot;, &quot;myClusterName&quot;).build();
Client client = TransportClient.builder().settings(settings).build();
//Add transport addresses and do something with the client...

// 设置sniff为true 能自动嗅探 host变更
Settings settings = Settings.settingsBuilder()
    .put(&quot;client.transport.sniff&quot;, true).build();
TransportClient client = TransportClient.builder().settings(settings).build();
</code></pre><blockquote>
<p>工厂类封装es客户端</p>
</blockquote>
<pre><code>//    1.es api接口实现类
public class ElasticSearchCenterImpl implements ElasticSearchCenter {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    private Client client = ElasticSearchClientFactory.createTransportClient();
    //封装es api 接口实现，通过client调用
}

// 2.es api接口定义
public interface ElasticSearchCenter {
    // 定义es api 接口方法
}

// 3.封装TransportClient工厂类 通过配置文件进行初始化
public class ElasticSearchClientFactory {
    private static volatile Client client;

    private ElasticSearchClientFactory() {
    }
    /**
     * create a transport client
     *
     * @return
     */
    public static Client createTransportClient() {
        if (client == null) {
            synchronized (Client.class) {
                if (client != null) {
                    return client;
                }
                ResourceBundle resourceBundle = ResourceBundle.getBundle(&quot;index-engine&quot;);
                String clusterName = resourceBundle.getString(&quot;es.cluster.name&quot;);
                String timeout = resourceBundle.getString(&quot;es.client.transport.ping_timeout&quot;);
                String hosts = resourceBundle.getString(&quot;es.hosts&quot;);
                String sniff = resourceBundle.getString(&quot;es.client.transport.sniff&quot;);

                Settings settings = ImmutableSettings.settingsBuilder()
                        .put(&quot;client.transport.sniff&quot;, sniff)
                        .put(&quot;cluster.name&quot;, clusterName)
                        .put(&quot;client.transport.ping_timeout&quot;, timeout)
                        .build();
                TransportClient innerClient = new TransportClient(settings);
                String[] hostPorts = hosts.split(&quot;,&quot;);
                for (String hostPort : hostPorts) {
                    String[] array = hostPort.split(&quot;:&quot;);
                    innerClient.addTransportAddress(new InetSocketTransportAddress(array[0], Integer.parseInt(array[1])));
                }
                client = innerClient;
            }
        }
        return client;
    }
}
</code></pre><blockquote>
<p>spring启动初始化工厂类</p>
</blockquote>
<pre><code>// 1.添加配置文件
es.hosts=ip:host,ip2:host2,ip3:host3,ip4:host4
es.cluster.name=es-engine-online
es.client.transport.ping_timeout=15000
es.client.transport.sniff=true
// 2.添加spring配置
&lt;!-- elasticsearch  --&gt;
&lt;bean id=&quot;elasticSearchCenter&quot; class=&quot;com.sohu.tv.index.data.engine.es.impl.ElasticSearchCenterImpl&quot; /&gt;
</code></pre><h2 id="ElasticSearch故障处理"><a href="#ElasticSearch故障处理" class="headerlink" title="ElasticSearch故障处理"></a>ElasticSearch故障处理</h2><h3 id="垃圾回收器工作情况"><a href="#垃圾回收器工作情况" class="headerlink" title="垃圾回收器工作情况"></a>垃圾回收器工作情况</h3><h3 id="IO调节"><a href="#IO调节" class="headerlink" title="IO调节"></a>IO调节</h3><h3 id="预热器的使用"><a href="#预热器的使用" class="headerlink" title="预热器的使用"></a>预热器的使用</h3><h3 id="热点线程分析"><a href="#热点线程分析" class="headerlink" title="热点线程分析"></a>热点线程分析</h3><p>热点线程：<a href="http://10.16.51.33:9200/_nodes/hot_threads?type=wait&amp;interval=1s" target="_blank" rel="external">http://10.16.51.33:9200/_nodes/hot_threads?type=wait&amp;interval=1s</a></p>
<h3 id="诊断集群和节点故障API"><a href="#诊断集群和节点故障API" class="headerlink" title="诊断集群和节点故障API"></a>诊断集群和节点故障API</h3><h2 id="Elasticsearch运维使用"><a href="#Elasticsearch运维使用" class="headerlink" title="Elasticsearch运维使用"></a>Elasticsearch运维使用</h2><h3 id="运维命令"><a href="#运维命令" class="headerlink" title="运维命令"></a>运维命令</h3><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><pre><code>ElasticSearch 官方文档 ： https://www.elastic.co/guide/index.html
Elasticsearch 权威指南（中文版）：http://es.xiaoleilu.com/
Elasticsearch资料 : http://blog.csdn.net/july_2/article/details/24453903
ElasticsSearch博客：http://blog.csdn.net/changong28/article/category/2381639/2    

lucene基本概念：http://forfuture1978.iteye.com/blog/546771
lucene文件格式解析：
http://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623597.html
http://www.cnblogs.com/forfuture1978/archive/2009/12/14/1623599.html
</code></pre>
      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/分布式搜索/" rel="tag">#分布式搜索</a>
          
            <a href="/tags/近实时搜索/" rel="tag">#近实时搜索</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/01/(7.1).分布式架构-dubbo/" rel="next" title="dubbo架构和源码分析">
                <i class="fa fa-chevron-left"></i> dubbo架构和源码分析
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/01/(8.1).JAVA虚拟机(一)-java体系结构及hotspot介绍/" rel="prev" title="Java体系结构及内存模型">
                Java体系结构及内存模型 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        
<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/metor.ico"
               alt="Pedestrian" />
          <p class="site-author-name" itemprop="name">Pedestrian</p>
          <p class="site-description motion-element" itemprop="description">study for goal</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">60</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">59</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/yanan0628" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://carlosfu.github.io/" target="_blank" title="fudada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  fudada
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://jolinzhangg.github.io/" target="_blank" title="xiaodada">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  xiaodada
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch初识"><span class="nav-number">1.</span> <span class="nav-text">ElasticSearch初识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍及特点"><span class="nav-number">1.1.</span> <span class="nav-text">介绍及特点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#介绍"><span class="nav-number">1.1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">1.1.2.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#elasticSearch整体架构："><span class="nav-number">1.1.3.</span> <span class="nav-text">elasticSearch整体架构：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与Lucene的区别？"><span class="nav-number">1.1.4.</span> <span class="nav-text">与Lucene的区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装及目录"><span class="nav-number">1.2.</span> <span class="nav-text">安装及目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#lucene相关概念"><span class="nav-number">1.3.</span> <span class="nav-text">lucene相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#elasticsearch-相关概念"><span class="nav-number">1.4.</span> <span class="nav-text">elasticsearch 相关概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch存储结构"><span class="nav-number">2.</span> <span class="nav-text">ElasticSearch存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#lucene文件存储格式"><span class="nav-number">2.1.</span> <span class="nav-text">lucene文件存储格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ElasticSearch存储模块"><span class="nav-number">2.2.</span> <span class="nav-text">ElasticSearch存储模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#store-level-throttling"><span class="nav-number">2.3.</span> <span class="nav-text">store level throttling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段合并策略"><span class="nav-number">2.4.</span> <span class="nav-text">段合并策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准实时、更新、提交及事务日志"><span class="nav-number">2.5.</span> <span class="nav-text">准实时、更新、提交及事务日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch分布式集群"><span class="nav-number">3.</span> <span class="nav-text">ElasticSearch分布式集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通信机制-发现模块"><span class="nav-number">3.1.</span> <span class="nav-text">通信机制-发现模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#故障转移-failover"><span class="nav-number">3.2.</span> <span class="nav-text">故障转移 failover</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#水平-垂直扩容-scale-Horizontally"><span class="nav-number">3.3.</span> <span class="nav-text">水平/垂直扩容 scale Horizontally</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ElasticSearch工作流程"><span class="nav-number">3.4.</span> <span class="nav-text">ElasticSearch工作流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由模块"><span class="nav-number">3.5.</span> <span class="nav-text">路由模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引别名模块"><span class="nav-number">3.6.</span> <span class="nav-text">索引别名模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch原理使用"><span class="nav-number">4.</span> <span class="nav-text">ElasticSearch原理使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文档存储及映射规则"><span class="nav-number">4.1.</span> <span class="nav-text">文档存储及映射规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">4.2.</span> <span class="nav-text">源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#API使用"><span class="nav-number">4.3.</span> <span class="nav-text">API使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch客户端使用"><span class="nav-number">5.</span> <span class="nav-text">ElasticSearch客户端使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#maven依赖"><span class="nav-number">5.1.</span> <span class="nav-text">maven依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户端TransportClient实例化"><span class="nav-number">5.2.</span> <span class="nav-text">客户端TransportClient实例化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ElasticSearch故障处理"><span class="nav-number">6.</span> <span class="nav-text">ElasticSearch故障处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收器工作情况"><span class="nav-number">6.1.</span> <span class="nav-text">垃圾回收器工作情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO调节"><span class="nav-number">6.2.</span> <span class="nav-text">IO调节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预热器的使用"><span class="nav-number">6.3.</span> <span class="nav-text">预热器的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#热点线程分析"><span class="nav-number">6.4.</span> <span class="nav-text">热点线程分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#诊断集群和节点故障API"><span class="nav-number">6.5.</span> <span class="nav-text">诊断集群和节点故障API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Elasticsearch运维使用"><span class="nav-number">7.</span> <span class="nav-text">Elasticsearch运维使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#运维命令"><span class="nav-number">7.1.</span> <span class="nav-text">运维命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">8.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pedestrian</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  



  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';                
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });
                            
                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').mousedown(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>

  

  

  

</body>
</html>
